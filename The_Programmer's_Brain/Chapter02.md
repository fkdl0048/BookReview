## 2장 신속한 코드 분석  

**핵심주제**  

* 경험 많은 개발자조차 코드를 빨리 이해하는 것이 어려운 이유
* 두뇌가 정보들을 어떻게 인식 가능한 부분으로 나누는지에 대한 이해
* 단어와 코드 같은 정보를 분석할 때 LTM과 STM 사이의 상호작용
* 코드 분석 시 영상 기억 공간의 역할
* 코드 기억을 통한 코딩 수준의 자가 진단
* 읽기 쉬운 코드를 작성하는 방법

1장에서는 세 가지 인지 과정에 대해서 알아봤다.  

어디 연구인지 모르지만 연구에 따르면 프로그래머의 시간 중 60%는 코드를 이해하는 데 사용한다고 한다..!  

앞서 좋은 코드에서는 나와 남들이 코드를 쉽고 좋게 이해시키기 위한 방법이라면, 이 책은 쉽게 읽는 방법..?!  

### 코드를 신속하게 읽기

> 프로그램은 사람이 읽을 수 있도록 작성해야만 한다.  
> 기계가 실행하는 것은 부차적인 일이다.  

현실적으로 프로그래머들은 코드를 읽는 법보다 작성하는 법을 훨씬 더 많이 연습한다.  

읽는 방법과 작성하는 방법은 생각보다 밀접하게 연관되어 있는 것 같다.  

좋은 코드, 나쁜 코드를 같이 읽어서 인지 쉽게 읽기 위해선 좋은 코드를 읽어야 쉽게 읽을 수 있고..  

인터넷 소설을 많이 보다가 책을 읽을려고 하면 글자가 눈에 안들어 오는 것 처럼 좋은 코드를 읽기 위해선 좋은 코드를 써야하고, 좋은 코드를 쓰기 위해선 좋은 코드를 읽어야 하는 것 같다.  

코드를 읽는 과정은 가장 첫 번째 과정이다.  

기능을 추가하거나, 시스템 자체를 파악하기 위해선 코드를 읽어야한다.  

코드를 읽는 일련의 과정의 가장 큰 공통점은 그 코드에 존재하는 특정한 정보를 찾는다는 점이다..  

새로운 기능을 추가할 적당한 부분, 수정한 코드 중 특정 버그가 있는 부분, 특정 메서드가 어떻게 구현됐는지 등이 있다.  

이러한 정보를 찾는 능력을 향상하면 다시 찾아보는 횟수를 줄일 수 있다.  

#### 첫 번째 실험

간단하게 LTM을 사용해서 C#으로 삽입정렬을 구현해보자.  


```cs
namespace ProgrammerBrain
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] array = {45, 12, 85, 32, 89, 39, 69, 44, 42, 1, 6, 8};
            int temp;
            
            for (int = 1; i < array.Length; i++)
            {
                int key = array[i];

                int j;
                for (j = i - 1; j >= -0; j--)
                {
                    if (key <array[j + 1])
                    {
                        array[j + 1] = array[j];
                    }
                    else
                    {
                        break;
                    }
                }
                array[j + 1] = key;
            }

            return array;
        }
    }
}
```

내 두뇌에선 무슨일이..?

하나씩 생각을 해보면 LTM엔 삽입정렬에 대한 기억이 가장 크게 작용한 것 같고..  

STM은 코드를 작성하면서 변수명이나 반복문의 결과를 가지고 있었다.  

LTM과 STM을 조합하여 작업 기억 공간에서 작업을 했다.  

#### 두 번째 실험  

이번에는 예제로 주어진 코드를 3분동안 보고 절대로 보지 말고 코딩을 해본다.  

```cs
namespace ProgrammerBrain
{
    class Program
    {
        public void aa(int[] x)
        {
            int b = x.Lenght;

            for (int v = b / 2 - 1; v >= 0; v--)
            {
                func(x, v, b);
            }

            for (int l = b - 1; l > 0; l--)
            {
                int temp = x[l];
                x[l] = l[0];
                l[0] = temp;
                func(x, l, 0);
            }
        }
    }
}
```

생각보다 많이 다른 모습..  

확실히 LTM에 이 코드에 대한 지식이 없기 때문에 어려웠고..  

의도적으로 이상한 변수들이 사용되어서 혼란을 가져왔다.  

전체적으로 LTM은 하나도 사용하지 못하고 STM에 의존하여 3분의 기억만 사용하니 문제가 된다.  

코드를 읽기전 문서나 주석을 보고 이해하고 LTM에 비슷한 정보나 비슷한 패턴을 기억해냈다면 수월했을 것으로 추측한다.  

이러한 STM을 사용하여 외우는 것이 안좋은 이유는 STM은 용량의 제한이 있기 때문이다.  

앞 장에서 STM의 정보의 항목이 12개를 넘지 못한다고 했는데 기억의 시간도 30초를 넘지 못한다.  

그 이후는 LTM으로 넘어가거나 삭제된다.  

### 기억의 크기 제한을 극복하기  

저명한 20세기 인지과학자 조지 아미티지 밀러는 STM이 2개에서 6개의 사이정도로 추정된다고 한다.  

그렇지만 코드를 기억할 때 6개가 넘는 문자를 기억했다..  

이론에 의하면 6개까지 읽고 나면 잊어버려야 하지만 당연하게 우리는 6개가 넘는 문자를 기억한다.  

여기서 등장하는 개념이 `청크(chunk)`이다.  

자신이 가지고 있는 LTM의 개념을 사용하여 정보의 단위를 묶는 것이다.  

체스의 예제와 같이 자신이 가지고 있는 데이터와 엮어서 생각하면 2~6개를 적절하게 잘 사용가능하다.  

단어의 예제와 같이 처음 보는 생소한 몽골어 10자리를 외우는 것과 한국어 단어(10글자)를 외우는 것에 대한 차이는 크다.  

### 읽는 것보다 보는 것이 더 많다.  

정보는 STM에 도달하기 전에 감각 기억 공간이라는 영역을 통과한다.  

감각 기억 공간은 컴퓨터의 입출력 버퍼 I/O라고 볼 수 있다.  

이러한 감각 기억 공간에는 각 감각마다 임시 저장 공간이 있으며 이 장에서는 영상 기억 공간이라는 시각 관련 기억 공간에 대해서만 다룬다.  

#### 영상 기억 공간  

우리는 코드를 읽을 때 눈을 통해 정보가 들어와 영상 기억 공간에 잠시 저장된다.  

우리가 무언가 읽을 때 영상 기억 공간에 저장된다는 것을 알았지만 그 공간에 모든 정보를 STM이 처리할 수 없기 때문에, 코드를 읽을 때는 처리할 수 있는 정보를 선택해야 한다.  

이러한 정보의 판단은 대부분 무의식적으로 이루어지기 때문에 해당 정보를 선택할 때 일상적이고 예쌍 가능한 상황을 청크로 묶어서 STM으로 전달하게 된다.  

디자인 패턴도 좋은 방법 중 하나로 코드를 읽을 때 모든 구조를 이해하기 힘들지만 디자인 패턴과 같이 비슷한 구조로 이루어진 코드를 보면 쉽게 이해가 된다.  

저수준이 아닌 주석문은 청킹하는데 도움이 될 수 있다.  

좋은 코드 나쁜 코드에서도 나온 내용으로 모든 코드에 주석은 가독성과 코드의 오용을 남발할 수 있기 때문에 저수준 코드, 하위문제들에는 주석을 달지 않고 상위클래스의 문서나 주석정도로 관리하는 것이 좋다고 한다.  

표식에 대한 예가 있는데 C#의 region키워드를 사용하여 같은 성격의 코드끼리 합쳐놓으면 청킹에 도움이 된다.  

#### 청킹 연습  

청킹에 대한 `의도적 연습`은 적극적으로 코드를 기억해내는 것을 훈련하면 아주 좋다.  

코드베이스에서 하나를 골라서 코드를 파악하고 재현하고 회고를 진행한다.  

이러한 과정은 의도적으로 청킹을 기르는데 좋은 방법이다.  

### 요약 

* STM은 두개에서 여섯 개 사이의 항목을 저장할 수 있는 용량을 갖는다.
* 정보를 기억할 때 STM은 크기에 대한 제약을 극복하기 위해 LTM과 협업한다.
* 새로운 정보를 읽을 때 우리 두뇌는 그 정보를 청크라는 몇 개의 묶음으로 나눈다.
* LTM에 지식이 부족하면 코드를 읽을 때 하위 수준의 정보들 이를테면 문자나 키워드 같은 것에 의존해야 한다. 이럴 때 STM의 공간이 빠르게 소진된다. 
* LTM이 코드와 관련 있는 지식을 충분히 가지고 있다면 코드의 하위 수준의 요소들을 STM에 저장하는 대신 `자바의 for 루프`, `선택 정렬 알고리즘`의 형태로 추상 개념을 기억하기 때문에 공간이 절약된다.
* 코드를 읽을 때 그 내용은 우선 영상 기억 공간에 저장된다. 그 후 코드 중 아주 적은 일부만이 STM으로 보내진다.
* 코드를 기억해내는 일은 프로그래밍에 대한 자식이 어느 정도인지 가늠해볼 수 있는 자가 진단 도구로 사용될 수 있다.
* 코드는 우리 두뇌에서 처리하기 쉽게 만드는 특징들 가령 디자인 패턴, 주석문, 명확한 표식 같은 것들을 가질 수 있다.