## 4장 복잡한 코드 읽는 방법

**핵심주제**  

* 작업 기억 공간이 복잡한 코드에 의해 과부하가 걸릴 때 어떤 일이 일어나는지 분석
* 프로그래밍에서 두 가지 종류의 작업 기억 공간 과부하
* 과부화가 걸린 작업 기억 공간을 보상하기 위해 읽기 쉬운 코드로 리팩터링하는 법
* 복잡한 코드를 읽을 때 작업 기억 공간을 지원하기 위한 상태표와 의존 그래프 생성하기

코드가 너무 복잡해서 완전히 이해하지 못하는 경우가 가끔 있다.  

대부분의 프로그래머가 코드 읽는 연습을 많이 해보지 않았기 때문에 이해되지 않는 코드를 다루는 방법론을 잘 모를 수 있다.  

**작업 기억 공간**의 기저에 있는 인지 과정을 알아본다.  

### 복잡한 코드를 이해하는 것이 왜 어려울까?  

내부의 복잡한 로직을 머리속으로 따라가다 보면 현재 변수값을 어디에 적고 싶은 욕구가 들 것이다.  

이는 우리의 두뇌가 처리할 용량이 부족하다는 것을 의미한다.  

#### 작업 기억 공간과 STM의 차이  

STM의 역할이 정보를 기억하는 것인 반면, 작업 기억 공간의 역할은 정보를 처리하는 것이다.  

작업 기억 공간도 STM과 같이 용량의 제한이 있다.  

이를 `인지 부화`라고 부르며 너무 많은 요소가 있어 청크로 나뉘지 않는 문제를 풀려고 할 때 작업 기억 공간은 `과부화`상태가 된다.  

#### 프로그래밍과 관련한 인지 부화의 종류  

인지부화의 종류는 크게 3가지로 나뉜다.  

* 내재적 부하: 문제 자체가 얼마나 복잡한지
* 외재적 부하: 외부적 요인에 의해 문제에 추가된 것
* 본유적 부하: 생각을 LTM에 저장하는 과정에서 일어나는 인지 부하

**내저적 인지 부화(intrinsic cognitive load)**는 문제 그 자체가 갖는 특성 때문에 발생하는 인지 부화이다.  

예를 들어 직각삼각형의 빗변의 길이를 계산하는 문제의 경우 피타고라스의 정리를 사용해서 풀어야 한다.  

이 외에는 다른 방법이 존재하지 않으며 이러한 문제를 내저적 인지 부화라고 한다.  

프로그래밍에서는 내재적 복잡성이라는 용어를 사용하여 문제의 내재적 측면을 설명한다.  

**외재적 인지 부화(extraneous cognitive load)**는 내재적인 부하에 `더해서` 문제에 추가되는 인지 부화다.  

직각 삼각형의 빗변의 길이를 계산할 때 밑변과 높이에 대한 값을 변수로 한번 매핑한 경우 이를 연결하는 과정을 외재적 업무로 추가 수행해야 한다.

#### 연습 문제  

익숙하지 않은 코드를 읽을 때 인지 부하를 모니터링해보기.  

코드를 읽을 때 잘 이해가 안 되고 뭔가 적어놓거나 단계별로 실행 순서를 따라가고 싶은 마음이 들면 인지 부하가 높은 것이다.  

인지 부하가 높을 때는 코드의 어느 부분이 다른 종류의 인지 부하를 유발하는지 확인해보면 좋다.  

### 인지 부화를 줄이기 위한 기법  

코드가 작업 기억 공간에 과부하를 초래하는 다양한 방식에 대해 살펴봤으므로 인지 부하를 줄이는 방법에 대해 알아보자.

#### 리팩터링  

리팩터링이란, 코드가 외부적으로 제공하는 기능은 유지한 채 내부 구조를 개선하는 것을 의미한다.  

간단한 예로 코드 블럭의 길이가 길면 여러 함수로 나누거나 재사용을 위해 중복된 코드를 하나로 통합하는 것을 말한다.  

하지만 유지 보수하기 좋게 수정됐다고 해서 가독성이 반드시 좋아지는 것은 아니다.  

메서드의 호출이 많은 코드를 생각해보면 메서드가 같은 파일 혹은 여러 파일에 걸쳐서 존재하는 메서드라면 모든 코드의 로직이 독립적이기 때문에 유지보수하기에는 좋은 코드이다.  

하지만 탈국지화된 코드는 여러 군데에서 메서드의 내부 구현을 찾아봐야 하기 때문에 작업 기억공간에는 어려움을 줄 수 있다.  

따라서 유지 보수하기 좋은 코드를 작성하기보다는 장기적으로 가독성이 높은 코드를 작성하도록 리팩터링하는 것이 좋을 수도 있다.  

이런 방식을 `인지적 리팩터링`이라고 정의한다.  

*유지보수하기 좋은 코드로 변경하는 것이 아닌 현 시점에서 개발자의 관점으로 읽기 쉬운 코드로 변경하는 것*  

인지적 리팩터링은 때로는 역 리팩터링을 수반할 수 있다.  

즉 오히려 코드의 유지 보수성을 더 낮추는 결과를 가져올 수 있다.  

책에서 나온 IDE의 추천이나 인라인 메서드, 메서드의 순서등 좋은 인지적 리팩터링 방법이다.  

내가 좋게 봤던 경우는 선언 부에서 중요도에 따라서 선언을 해두고 순서를 맞춰두니 좋았던 경우가 있다.  

##### 생소한 언어 구성 요소를 다른 것으로 대치하기  

코드를 읽을 때 혼란이 되는 세 가지 원인, 즉 지식 부족, 정보 부족, 처리 능력 부족을 극복하는데 도움이 되는 기법에 대해 이제부터 다뤄보겠다.  

C#, Java의 람다식 그리고 파이썬의 컴프리헨션은 간단하고 가독성 높은 코드를 만들 때 유용하지만 많은 프로그래머는 람다에 익숙하지 않으며 for루프나 while루프를 읽고 이해하는 것보다 어려워한다.  

간단한 람다는 문제가 되지 않지만 복잡한 경우에는 작업 기억 공간에 과부화가 발생한다.  

익숙하지 않은 언어 구성 요소는 작업 기억공간에 외재적 인지 부하를 늘리기 때문에 복잡한 코드를 읽을 때는 이들로 인한 부하가 늘어나지 않게 하는 것이 좋다.  

#### 작업 기억 공간에 부하학 오면 쓸 수 있는 기억 보조 수단  

리팩터링을 통화 인지 부하를 줄이는 방법을 소개했지만 여전히 코드의 구조가 복잡하다면 작업 기억 공간에게는 과부하다.  

1. 정확히 코드의 어디를 파악해야 하는지 모를 때이다.  

이 경우에는 필요 이상으로 많은 코드를 읽게 되고 이것은 작업 기억 공간이 처리할 수 있는 것보다 많은 양이 될 수 있다.  

2. 코드가 서로 밀접하게 연결되어 있는 경우 두뇌는 두 가지 작업을 동시에 수행한다.  

코드의 개별 라인을 이해하면서 어느 부분을 계속 읽어야 하는지 판단하기 위해 코드의 구조를 이해해야 한다.  

예를 들어 정확히 무슨 일을 하는지 알지 못하는 메서드에 대한 호출이 코드에서 이루어진다면 코드 파악을 계속하기 전에 우선 그 메서드를 찾아서 읽어야 한다.  

##### 의존 그래프 생성  

코드를 바탕으로 의존 그래프를 만들면 흐름을 이해하고 논리적 흐름에 따라 코드를 읽는 데 도움이 된다.  

코드를 프린트하거나 PDF로 만들어서 디지털 주석을 달면 좋다..?  

비슷한 변수나 함수의 호출 정의를 연결하는 방법인데... 플래시카드와 마찬가지로.. 생소한 방법이라고 생각한다.  


#### 상태표

리팩터링을 통해 어려운 코드를 자신의 지식에 맞는 쉬운 형태로 바꾸고 코드에 의존관계를 표시한 후에도 코드가 여전히 이해가 안 될 수 있다.  

때로는 코드의 구조 때문에 이해가 어려운 것이 아니라 코드에서 수행하는 계산 로직 때문에 어려울 수 있다.

#### 의존 그래프와 상태표의 혼용  

앞서 설명한 두가지 방법을 혼용해서 사용하면 구조와 결과에 대한 정보를 쉽게 이해할 수 있다.  

### 요약

* 인지 부하는 작업 기억 공간이 처리할 수 있는 한계를 나타낸다. 인지 부하가 너무 크면 두뇌가 코드를 적절하게 처리할 수 없다.
* 프로그래밍과 관련해 두 가지 종류의 인지 부하가 있다. 내재적 인지 부하는 코드에 존재하는 복잡성에 기인하고 외재적 인지 부하는 우발적으로 혹은 코드를 읽는 개발자의 지식의 부족에 기인한다.
* 리팩터링은 코드를 읽는 사람이 이미 가지고 있는 지식에 맞춰 코드를 변경함으로써 외재적 인지 부하를 줄이는 방법이다.  
* 의존 그래프는 복잡하고 서로 밀접하게 연결되어 있는 코드를 이해하는 데 도움이 된다.
* 코드의 실행 도중에 변수가 갖는 값을 보여주는 상태표는 계산이 많이 수행되는 코드를 파악하는 데 유용하다.

아직은 코드를 읽는데 어려움이 없었던건지 그냥 읽고싶은대로 읽은건지 책에서 제시하는 여러가지 방법에 대한 생각이 크게 좋은 방향은 아닌 것 같다.  

