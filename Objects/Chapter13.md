## 13장 서브클래싱과 서브타이핑

상속에 대한 오해와 불신은 많지만 궁극적으로 상속은 두 가지 용도로 사용된다.

상속의 첫 번째 용도는 타입 계층을 구현하는 것이다. 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다. 타입 계층의 관점에서 부모 클래스는 자식 클래스의 **일반화(generalization)**이고 자식 클래스는 부모 클래스의 **특수화(specialization)**이다.

상속의 두 번째 용도는 **코드 재사용**이다. 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있는 마법의 주문과도 같다. 상속을 사용하면 점진적으로 애플리케이션의 기능을 확장할 수 있다. 하지만 재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높다.

상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다. 상속은 코드를 쉽게 재사용할 수 있는 방법을 제공하지만 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 설계의 변경과 진화를 방해한다. 반면 타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있게 된다.

*이 예로 내가 생각한 타입의 계층은 깊어지는 하위 클래스들의 타입을 묶기에 되게 적합하다는 생각이 든다. 오우거라는 몬스터가 있을 때, 오우거는 합성으로 만들고 이에 대한 타입을 상속 구조로 북부의 오우거, 남부의 오우거, 동부의 오우거 등으로 하나의 타입으로 볼 수 있다는 점?*

*or 게임 엔진이라는 특수성 위에 즉, 어떠한 툴, 엔진에 종속적인 구조를 만들 때 유용한 것 같다.*

결론은 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다. 상속의 가치는 이러한 타입 계층으로 구현할 수 있는 쉽게 편안한 방법을 제공한다는 데 있다. 타입 사이의 관계를 고려하지 않은 채 단순히 코드를 재사용하기 위해 상속을 사용해서는 안 된다.

### 타입

> 객체지향 프로그래밍에서 타입의 의미를 이해하려면 프로그래밍 언어의 관점에서의 타입과 개념 관점에서의 타입을 함께 살펴볼 필요가 있다.

#### 개념 관점의 타입

개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다. 다시 말해 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입이라고 한다.

어떤 대상이 타입으로 분류될 때 그 대상을 타입의 **인스턴스(instance)**라고 한다. *언어적으로는 인스턴스를 객체라고 칭한다.*

- 심볼(symbol): 타입에 이름을 붙인 것으로 프로그래밍 언어인 C, C#, C++이 프로그래밍 언어라는 타입일 때, 프로그래밍 언어가 심볼이다.
- 내연(intension): 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다. 프로그래밍 언어 타입의 경우 프로그래밍 언어의 공통적인 특징이 내연을 구성한다.
- 외연(extension): 타입에 속하는 객체들의 집합이다. 프로그래밍 언어 타입의 경우 C, C#, C++가 속한 집합이 외연을 구성한다.

#### 프로그래밍 언어 관점의 타입

프로그래밍 언어 관점에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다. (비트 자체에는 타입이라는 개념이 존재하지 않는다.) 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 전적으로 데이터를 사용하는 애플리케이션에 의해 결정된다. 따라서 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다.

*실제 데이터는 비트로 표현되기에, 우리는 클래스라는 타입, 정수라는 타입이로 이를 디코딩하여 사용한다.*

프로그래밍 언어에서는 타입은 두 가지 목적을 위해 사용된다.

- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
  - `+`연산자를 통해 정수나 문자열 타입의 객체에 대해서 연산이 가능하고 C#이나 C++은 연산자 오버로딩을 통해 객체에 대한 연산을 정의할 수 있다. 모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다.
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.
  - C#의 new 연산자의 경우 타입에 정의된 크기만큼 저장 공간을 할당하고 생성된 객체를 초기화하기 위해 타입 생성자를 호출한다.

즉, 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.

#### 객체지향 패러다임 관점의 타입

- 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다.
- 프로그래밍 언어 관점에서 타입이란 **동일한 오퍼레이션을 적용할 수 있는 인스턴스의 집합**이다.

프로그래밍 언어의 관점에서 타입은 호출 가능한 오퍼레이션의 집합을 정의한다. 객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미한다. 따라서 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의한다.

*이것은 int, string도 마찬가지다. 타입이란 객체가 수신할 수 있는 메시지의 종류!*

객체가 수신할 수 있는 메시지의 집합이라는 말은 **퍼블릭 인터페이스**라는 말이며 즉, 객체지향 프로그래밍에서 타입을 정의하는 것은 결국 객체의 퍼블릭 인터페이스를 정의하는 것이다. 다시 말해서 객체의 핵심은 행위라는 것이다.

개념 관점에서 타입은 공통의 특성을 가진 객체들을 분류하기 위한 기준으로 그렇다면 여기서 공통의 특성이란 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입으로 분류할 수 있다.

*같은 클래스가 아닌 같은 인터페이스를 구현한 객체들, 결국 상속, 다형성을 하게 되면 같은 인터페이스를 지닐 수 밖에 없게 되기에 같은 인터페이스를 구현한 객체들이라는 말이 선행되어야 하고 더 큰 분류로 봐야 한다.*

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.

**객체에게 중요한 것은 속성이 아니라 행동이라는 것이다.** 어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르다면 이들은 서로 다른 타입으로 분류된다. 반대로 어떤 객체들이 내부 상태는 다르지만 동일한 퍼블릭 인터페이스를 공유한다면 이들은 동일한 타입으로 분류된다.

객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다. 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 **외부에 제공하는 행동**이라는 사실을 기억하라.

### 타입 계층

#### 타입 사이의 포함관계

