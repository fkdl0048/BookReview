## 오버로딩에 의한 다형성

### 오버로딩

함수 오버로딩은 한 함수가 여러 타입의 인자를 받아야 할 때 `이거나` 타입보다 훨씬 간단하고 직관적인 해결책을 제공하는 기능이다. 함수 오버로딩이란 같은 이름의 함수를 여러 개 정의하는 것이다. *overloading은 `너무 많음`이라는 뜻을 가지고 있기에 원래 한 이름의 함수를 하나만 정의해야 하지만, 편의상 같은 이름의 함수를 `너무 많이` 정의할 수 있도록 하는 기능이다.*

책에서 보여주는 함수 내부에서 타입 검사(사용자 if)를 할 필요 없이 오버로딩을 통해 단순하게 다형성을 추가할 수 있다. 직관적이기는 하지만 중복성은 피하기 힘들다. *실제로 이를 줄이기 위해 또 내부의 동작을 함수로 묶고 나누는 과정이 많아지면 결국 배보다 배꼽이 커지는 경우가 많다. 결국은 또 트레이드 오프*

```cs
write(c1, "hello");
write(c2, 42);
```

위와 같이 사용하는 오버로딩 함수에서 어떤 것을 호출할지는 언어 수준에서 자동으로 결정된다. 이렇게 함수가 오버로딩되어 있을 때 호출할 함수를 자동으로 고르는 것을 **함수 선택**이라 부른다.

- 함수 선택 규칙
  - 인자의 타입에 맞는 함수를 고른다.
  - 인자의 타입에 가장 특화된 함수를 고른다.
  - 함수를 고를 때는 인자의 정적 타입만 고려한다.

*어떻게 보면 오버로딩은 설계자, 제작자보다 사용자의 입장에서 조금 더 편리하게 사용할 수 있도록 하는 기능이라고 볼 수 있다.*

오버로딩은 다형성을 만들어 내는 세 번째 방법이다. (첫 번째는 서브타입, 두 번째는 제네릭) 그 이유는 `write`라는 이름은 (cell, string) => void 타입이면서 (cell, int) => void 타입인 것으로 이해할 수 있다. **write라는 하나의 대상이 여러 타입을 가지는 것이다.**

*하나의 대상이 여러 타입을 가진다는 것이 다형성의 가장 기본적인 근본이라고 생각이 된다. 오버로딩도 다형성이라고 알고는 있었지만 타입 검사 입장에서 보니 기본적인, 통일된 개념을 잘 이해할 수 있었다.*

그러므로 이 역시 다형성이다. 이렇게 같은 이름을 여러 번 정의함으로써 만들어지는 다형성을 오버로딩에 의한 다형성이라고 부른다.

오버로딩이란 `함수 오버로딩`, `메서드 오버로딩`, `연산자 오버로딩`을 모두 통틀어 일컫는 용어다.

#### 가장 특화된 함수

앞서 다훈 함수 선택 규칙의 두 번째 항목인 `인자의 타입에 가장 특화된 함수를 고른다` (더 구체화 된)은 개발자 입장에서 상당히 합리적인 규칙이다. 당연히 정의한 이유가 더 특화, 추가적인 기능이 있기 때문에 새로운 클래스를 담은 오버로딩 함수를 만들었기 때문이다.

동적 타입과 정적 타입은 실제로 다형성에서 가장 많이 다루는 개념이다. 코드상으로 보이지않는 동적 흐름을 자연스럽게 설계해야 유연한 코드가 된다.

**대부분의 언어가 함수 선택 시 정적 타입만을 고려하기 때문에 이 정적 선택을 잘 이해해야 한다.** *실제 내 의도와 다르게 동작하기 때문이다.* 가장 간단한 방법은 서브타입이 존재할 때 가급적 같은 이름으로 함수를 추가 정의하는 일을 피하는 것이다.

#### 메서드 오버로딩

메서드 오버로딩은 함수에서 메서드로 바뀌었을 뿐 개념은 같다.

### 메서드 오버라이딩

메서드 오버라이딩은 특화된 동작을 정의하는 가장 좋은 방법이다. **메서드 오버라이딩은 클래스를 상속해서 자식 클래스에 메서드를 새로 정의할 때 메서드의 이름과 매개변수 타입을 부모 클래스에 정의되어 있는 메서드와 똑같게 정의하는 것을 말한다.**

*가장 쉽게 다형성을 효과적으로 볼 수 있는 기초적인 방법*

`overriding`이라는 단어의 사전적인 뜻은 '자동으로 진행되는 동작을 사람이 개입하여 중단시킨 뒤 스스로 조작하는 것'이다. 이를 바탕으로 메서드 오버라이딩을 이해하자면 `vector`에 있던 length 메서드가 상속을 통해 자동으로 `SparseVector`에도 정의되는 것을 개발자가 개입하여 막은 뒤 기존 length 메서드와 다른 동작을 수행하는 새로운 length 메서드를 정의하는 것이다.

함수 오버로딩 즉, 메서드 오버로딩과 다른 점은 정적 타입이 `vector`라도 `sparseVector`의 메서드를 호출하여 실행한다는 점이다.

```cs
Vector v = new SparseVector();
v.length();
```

이 코드는 동적 타입으로 동작한다. **이처럼 메서드 오버라이딩을 사용하면 서브타입을 위해 더 특화된 동작을 정의하고, 정적 타입에 상관없이 언제나 그 특화된 동작이 사용되도록 만들 수 있다.** *앞서 개발자에게 더 인지적인 두 가지 동작 모두 충족*

*책에서는 타입 검사기의 측면에서 다루지만 C++을 조금 공부한다면 실제 메모리 구조 즉, 객체의 타입이 어떻게 담기고 운용되는지를 알면 이는 간단한 문제이다.*

- **메서드** 선택 규칙
  - 인자의 타입에 맞는 함수를 고른다.
  - 인자의 타입에 가장 특화된 함수를 고른다.
  - 메서드를 고를 때는 인자의 정적 타입만 고려한다.
  - 메서드를 고를 때는 수신자의 **동적 타입**도 고려한다.

#### 메서드 선택의 한계

앞서 다룬 수신자의 동적 타입을 고려한다하는 것만으로 모든 문제가 해결되지 않는다. **문제는 수신자의 동적 타입만 고려하고 인자의 동적 타입은 고려하지 않는 데서 온다.**

책에서 나오는 예제와 같이 단순한 경우에는 문제가 없지만 덧셈과 같이 타입이 다르게 나뉘는 경우(반환자와 매개변수의 차이)에서 수신자(반환자)는 정적타입이지만 메서드 오버라이딩이기에 동적 타입을 읽고, 매개변수는 그대로 정적 타입으로 해석하기 때문에 비효율적인 문제가 생길 수 있다.

이는 결국 처음에 말한 개발자의 기대와 다른 동작이 발생하는 것이다. 이를 해결하기 위해서 매개변수의 실제 타입을 뽑아낼 수 있는 `this`키워드를 사용하여 해결이 가능하긴 하다.

#### 메서드 오버라이딩 결과 타입

지금까지 다룬 매개변수에서만 오버로딩을 다뤘는데 결과타입도 마찬가지로 다형성이 가능하다. 반면 메서드 오버라이딩을 할 때는 결과 타입을 아무렇게나 해서는 안 된다. **자식 클래스에 정의한 메서드의 결과 타입이 부모 클래스에 원래 있는 메서드의 결과 타입의 서브타입이어야 한다.** *모든 타입은 자기 자신의 서브타입이니 이 조건은 두 메서드의 결과 타입이 같은 경우도 포함한다.*





### 정리

### 논의사항

