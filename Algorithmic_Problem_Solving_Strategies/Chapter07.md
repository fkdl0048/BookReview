## 7장 분할 정복

분할 정복(Divide & Conquer)은 가장 유명한 알고리즘 디자인 패러다임으로, 각개 격파라는 말로 설명이 가능하다. 이 디자인 패러다임을 차용한 알고리즘은 **주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 통해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산**해 낸다. 분할 정복이 일반적인 재귀호출가 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신 거의 같은 크기의 부분 문제로 나누는 것이다.

![image](https://github.com/fkdl0048/BookReview/assets/84510455/7ee6cc00-7cc4-4664-8133-1830d2973688)

*그림에서 알 수 있듯이 세로가 더 짧다.*

분할 정복을 사용하는 알고리즘들은 대개 세 가지의 구성 요소를 가지고 있다.

- 문제를 더 작은 문제로 분할하는 과정(divide)
- 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정 (merge)
- 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제(base case)

*위 분할정복의 알고리즘은 마치 잘 구현된 코드와 같은 형태를 가져야 한다. (클래스의 세분화)*

위 특성에서 알 수 있듯이 분할 정복을 적용하기 위해선 문제에 몇 가지 특성이 성립해야 한다. 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야 하며, 부분 문제의 답을 조합해 원래 문제의 답을 계산하는 효율적인 방법이 있어야 한다. 적용하기 어려워 보이는 조건을 가지지만 분할 정복은 같은 작업을 더 빠르게 처리할 수 있다는 장점이 있다.

### 예제: 수열의 빠른 합과 행렬의 빠른 제곱

앞서 재귀 호출에 대해서 다룰 때 `recursiveSum()`이라는 함수를 통해 `1 + 2 + ... + n`을 다뤘는데 이를 분할정복을 이용해 `fastSum()`함수를 만들어 보자. 1부터 n까지의 합을 n개의 조각으로 나눈 뒤, 이들을 반으로 뚝 잘라 n/2개의 조각들로 만들어진 부분 문제 두 개를 만든다. (편의상 n은 짝수로 가정)

$$ fastSum() = 1 + 2 + \cdots + n $$
$$ = (1 + 2 + \cdots + \frac{n}{2}) + ((\frac{n}{2} + 1) + \cdots + n) $$

첫 번째 부분 문제는 fastSum(n/2)로 나타낼 수 있지만, 두 번째 부분 문제는 그렇지 않다. 문제를 재귀적으로 풀기 위해서는 각 부분 문제를 '1부터 n까지의 합' 꼴로 표현할 수 있어야 하는데, 두 번째 조각은 'a부터 b까지의 합' 형태를 가지고 있기 때문이다. 따라서 다음과 같이 두 번째 부분 문제를 fastSum(x)를 포함하는 형태로 바꿔 써야 한다.

$$ (\frac{n}{2}+1)+\dotsb+n=(\frac{n}{2}+1)+(\frac{n}{2}+2)+\dotsb+(\frac{n}{2}+\frac{n}{2})$$

$$ =\frac{n}{2}\times\frac{n}{2}+(1+2+3+\dotsb+\frac{n}{2})$$
$$ =\frac{n}{2}\times\frac{n}{2}+ fastSum(\frac{n}{2})$$

따라서 다음과 같이 쓸 수 있다.

$$ fastSum(n) = 2 \times fastSum(\frac{n}{2}) + \frac{n^2}{4} $$

이를 코드로 구현하면 다음과 같다.

```cs
// 필수 조건: n은 자연수
// 1 + 2 + ... + n을 반환한다.
int fastSum(int n) {
    // 기저 사례(base case)
    if (n == 1) return 1;
    if (n % 2 == 1) return fastSum(n-1) + n;
    return 2*fastSum(n/2) + (n/2)*(n/2);
}
```

#### 시간복잡도 분석

fastSum()은 recursiveSum()에 비해서 훨씬 호출횟수가 적을 것이라 예상할 수 있는데, 이는 호출할 때마다 두 번에 한 번 꼴로 n이 절반으로 줄어들기 때문이다.

#### 행렬의 거듭제곱

n x n 크기의 행렬 A가 주어질 때, A의 거듭제곱(power)A^m는 A를 m번 곱한 것을 의미한다. 이것을 계산하는 것은 크게 어려울 것이 없지만, m이 매우 클 때 A^m을 계산하는 것은 어려울 수 있다.

*분할정복은 매우 빠른 속도로 구할 수 있다.*

위 아이디어를 사용하여 A^m을 구하는데 필요한 m개의 조각을 절반으로 나눠 보자.

$$ A^m = A^{m/2} \times A^{m/2} $$

이를 코드로 구현하면 다음과 같다.

```cs
// 정방 행렬을 표현하는 SquareMatrix 클래스가 있다고 가정한다.
// A^m을 반환한다.
SquareMatrix pow(const SquareMatrix& A, int m) {
    // 기저 사례: A^0 = I
    if (m == 0) return identity(A.size());
    if (m % 2 > 0) return pow(A, m-1) * A;
    SquareMatrix half = pow(A, m/2);
    return half * half;
}
```

#### 나누어 떨어지지 않을 때의 분할과 시간 복잡도

m이 홀수일 때, A^m=AxA^(m-1)로 나누지 않고, 좀더 절반에 가깝게 나누는 게 좋지 않을까라는 생각을 할 수도 있다. 예를 들어 7을 6,1이 아닌 3,4로 나누는 것이다. 실제로 문제의 크기가 절반에 가깝게 줄어들면 기저 사례에 도달하기까지 걸리는 분할의 횟수가 줄어들기 때문에 대부분의 분할 정복 알고리즘은 가능한 한 절반에 가깝게 문제를 나누고자 한다.

*실제로 퀵 정렬에서 좀더 좋은 분할을 찾기 위해 여러 노력을 하는 것과 같다.*

하지만 이 문제의 경우 분할은 오히려 알고리즘을 더 느리게 만든다. A^m을 찾기 위해 계산해야 할 부분 문제의 수가 늘어나기 때문이다.

![image](https://github.com/fkdl0048/BookReview/assets/84510455/47243978-8846-4134-9ecd-3a3bdbb402d1)

같은 문제라도 어떻게 분할하느냐에 따라 시간 복잡도 차이가 커진다는 것을 보여주는 좋은 예이다. **절반으로 나누는 알고리즘이 큰 효율 저하를 불러오는 이유는 바로 여러 번 중복되어 계산되면서 시간을 소모하는 부분 문제들이 있기 때문이다**. 이런 속성을 부분 문제가 중복된다라고 부른다.
(이후에 동적계획법이 고안된 계기가 된다.)
