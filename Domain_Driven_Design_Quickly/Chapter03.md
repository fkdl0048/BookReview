## 3장: 모델 주도 설계

앞서 다룬 내용은 도메인 전문가와 대화를 통해 도메인에 대한 깊은 이해를 바탕으로 모댈링을 하는 과정을 말했다면 다음으로 중요한 모델을 코드로 구현하는 과정을 설명한다.

모델링된 모델을 두고 개발자는 자신의 생각을 덧붙여서 고유한 설계를 만들어낸다. 개발이 계속되면서 더 많은 클래스가 추가되며 코드와 모델사이의 간격이 넓어진다. 설계자와 개발자를 분리시키거나 모델과 코드를 분리하는 등의 개발방식은 켤코 좋은 소프트웨어를 생산하지 못한다.

*아마 프로그래밍이 매력적인 이유도 같은 도메인이라도 전부 다른 설계를 만들어내기 때문이라 생각된다.*

**코드를 작성하는 사람은 모델을 아주 잘 알고 있어야 하고, 모델의 무결성에 대해 책임감을 느껴야 한다. 그리고 코드의 변경은 곧 모델의 변경을 의미한다는 것을 깨달아야 한다.**

결국 이 말은 모델에 기여하는 기술자들은 모두 역할에 상관없이 코드에 기여하는 작업을 해야하고 코드를 변경하는 책임이 있는 모든 사람들은 코드를 통해 모델을 표현하는 방법을 배워야 한다. 모든 개발자도 모델을 주제로 한 일정 수준의 논의에 참석하고 도메인 전문가와 만나야 한다. *여기서 중요한 것이 유비쿼터스 언어의 필요성이다.*

이런 과정이 불필요하다고 느껴지고 모델과 설계의 핵심 부분이 잘 맞아 떨어지지 않는다면 모델은 가치가 없으며 오히려 비용적인 측면이 강화될 것이다.

**소프트웨어 시스템의 각 부분은 도메인 모델이 글자 그대로 반영 되도록 설계해야 한다. 코드는 결국 모델을 표현한 것이고, 코드의 변경이 곧 모델의 변경으로 이어질 것이다.**

객체지향프로그래밍(OOP)는 모델을 구현하기 적합한 패러다임으로 모델을 투사하여 표현하기에 유용하다. 복잡한 도메인은 절차적 언어로 대응하는 모델을 만들어내는 데 한계가 있다.

### 모델 주도 설계를 위한 블록

모델 주도 설계에서 사용되는 가장 중요한 패턴들을 소개한다. 여기 등장하는 패턴들의 목적은 도메인 주도 설계 관점에서 객체 모델링 및 소프트웨어 설계의 핵심 요소들을 보여주는 데 있다.

#### 계층형 아키텍처

실제로 애플리케이션을 만들 때, 상당 부분은 도메인과 직접적인 연관이 없는 부분이 많다. 그 목적을 동작하게 하기 위한 제반 시스템이 주를 이루거나 도메인은 다른 부분에 비해 적은 비중을 차지한다. *네트워크 코드, 데이터베이스, 사용자 인터페이스 등등..*

객체지향 프로그램에서 UI, 데이터베이스, 도메인과 직접 관련되어 있지 않은 여타 지원 성격의 코드들은 흔히 직접 비즈니스 객체 내부에 작성된다. 이런 경우는 대부분 일을 가장 빠르게 처리할 수 있기 때문이다.

그러나 이처럼 도메인과 관련된 코드가 다른 레이어와 섞여 있다면, 다른 사람이 코드를 읽고 이해하기가 매우 어렵다. 결국 프로그램이 복잡해지고 테스트도 어려워 진다.

따라서 복잡한 프로그램을 '레이어'로 분할해야 한다. **각 레이어 내부에서 설계를 수행하여 응집도 높고 자기 하위 레이어에만 의존하도록 만들어야 한다**. 또한 상위의 레이어에 대한 결합도를 낮추려면 표준적인 아키텍처 패턴을 따라야 한다.

하나의 레이어에 도메인과 관련된 모든 코드를 집중시켜서, 사용자 인터페이스, 애플리케이션, 인프라스트럭처 코드로부터 독립적으로 만들어야 한다.

- 사용자 인터페이스
  - 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임을 진다.
- 애플리케이션 레이어
  - 애플리케이션 활동을 조율하는 얇은 레이어다. 업무 로직을 포함하지 않는다. 비즈니스 객체의 상태를 보관하지 않지만, 애플리케이션 작업의 처리 상태는 보관한다.
- 도메인 레이어
  - 도메인의 정보를 포함한다. 업무 소프트웨어의 심장에 해당한다. 비즈니스 객체의 상태를 포함한다. 비즈니스 객체와 이 객체의 상태 정보 중 가능한 부분의 영속성에 대한 책임은 인프라스트럭처 레이어로 위임된다.
- 인프라스트럭처 레이어
  - 다른 레이어 모두를 지원하는 라이브러리로 동작한다. 레이어 간의 통신을 제공하고 비즈니스 객체의 영속성을 구현하고 사용자 인터페이스 레이어의 라이브러리를 포함한다.

애플리케이션을 분할된 레이어를 나누고 레이어 간의 상호작용 규칙을 수립하는 일은 매우 중요하다. *게임도 마찬가지로 레이어가 존재한다. 다만 명칭은 다르지만 목적성은 동일하다고 생각된다.*

레이어를 분할했다는 것은 도메인 레이어는 핵심 도메인 이슈에만 집중해야 한다. *조금 더 확장해서 이렇게 레이어를 분할하여 상위 레이어가 하위 레이어에 일반적인 의존을 가지는 것은 꼭 레이어에 국한된 것이 아니라 더 작은 부분에서도 이 법칙이 적용되어야 한다. 예를 들어 UI레이어 코드 내에서도 여러 계층을 만들고 그 계층끼리 앞서 말한 구조를 유지해야 응집도가 높고 결합도가 낮은 구조가 재귀적으로 만들어진다.*

#### 엔티티

소프트웨어가 여러 상태를 거치는 동안에도 동일한 값을 유지하는 식별자를 지니는 유형의 객체가 있다. **이러한 객체들에게 중요한 것은 속성이 아니라, 시스템 전 생명주기 동안, 또는 그 이상으로 확장될 수 있는 연속성과 식별성의 흐름이다. 이러한 객체를 엔티티라고 부른다.**

사람의 주민등록번호, 게임 유저의 고유 코드 ID, 사람의 경우 여러 속성들의 조합, 계좌번호 등 이러한 고유한 식별자로 객체를 구분 및 관리한다. 객체가 일반 속성이 아닌 식별자에 의해 구별된다면, 모델의 해당 객체 정의에는 주로 이 식별자가 반영되어야 한다.

엔티티는 도메인 모델에서 매우 중요한 객체들이고, 모델링 작업을 시작할 때부터 깊이 고민해야 할 부분이기도 하다. 더불어 어떤 객체를 엔티티로 봐야 할지 말아야 할지 여부를 결정하는 작업 또한 매우 중요하다.

#### 값 객체

엔티티는 도메인 모델링에 필수적이다. 엔티티는 추적이 될 수 있어야 한다. 추적 가능하다는 것은 그만큼의 비용을 지불해야 한다는 것을 말한다. 즉, 모든 객체를 엔티티로 만들면 성능상의 문제가 발생할 수 있다.

**값 객체는 영속성이 필요 없는, 하나의 객체가 도메인의 어떠한 측면을 표현하는 데 사용되지만 식별자가 없는 경우이며, 이것을 값 객체라고 부른다.**

쉽게 값 객체를 떠올리듯이 엔티티의 정의에 부합하는 객체만을 엔티티로 두고 나머지를 값 객체로 만들어라. 이렇게 하면 설계가 좀 더 단순화되고, 다른 긍정적인 결과도 생긴다.

값 객체는 알아서 소멸될 것이다 (GC에 의해), 다만 값 객체는 수정할 수 없게 만들어야 한다. 생성자를 통해 값 객체를 생성하고 나면 생명주기 동안 상태가 변경되지 않는다. (필요하다면 복사하여 수정) 값 객체가 불변을 보장해야 한다는 것은 객체지향의 기본적인 원리이자 황금률이다.

#### 서비스

도메인을 분석하여 모델을 구성하는 주요 객체를 정의할 때 도메인의 특정 부분들은 객체로 쉽게 매핑될 수 없다는 사실을 발견하게 된다. 예를 들어 한 계좌에서 다른 계좌로 돈을 보내는 기능의 경우 어떤 계좌에 이 기능이 존재해야 하는지에 대한 문제이다.

어느 한쪽도 아니고 이는 서비스에 해당한다. **서비스 객체는 내부적인 상태를 가지지 않으면서, 단순히 도메인에 기능을 제공하는 목적을 지닌다.** 서비스가 제공하는 기능은 매우 중요하고, 서비스는 엔티티와 값 객체에 기여하는 관련된 기능을 묶을 수 있다.

서비스는 하나의 개념들 캡슐화하여 도메인에서 명확하게 구분되어 만들어지기 때문에, 명시적으로 선언하는 편이 좋다. 엔티티나 값 객체에 이런 기능을 넣는다면 해당 객체의 의미를 불분명하게 만들어 혼란스러워질 것이다.

*서비스는 오퍼레이션을 제공하는 인터페이스와 비슷하게 동작한다.*

- 서비스 특징
  - 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값 객체에 속할 수 없는 도메인의 개념을 나타낸다.
  - 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다.
  - 오퍼레이션은 상태를 저장하지 않는다.

애플리케이션이나 도메인 서비스들은 양쪽 모두 그 객체들과 직접 관계된 기능을 제공하는 도메인 엔티티와 값 위에 만들어진다. 따라서 서비스가 속하는 레이어를 결정하기는 어렵다.

*서비스라는 명칭을 익숙하지 않게 느낀 것 같다. 실제로 객체의 책임이 예매해지는 경우가 종종 있는데 그럴 때 마다 다른 객체를 만들어 위임하는 등 여러 방법들을 사용했지만 설계 단계에서 그걸 서비스라는 명칭으로 정의할 수 있다는 점이 마음에 든다.*

하지만 오퍼레이션이 개념적으로 애플리케이션 레이어에 속하는 일을 한다면 해당 서비스는 그 레이어에 존재하는 게 맞다. 같은 맥락으로 도메인 레이어도 마찬가지다. 즉, 서비스도 레이어에 맞게 존재해야 한다.

#### 모듈

규모가 크고 복잡한 애플리케이션의 경우 그 모델은 점점 더 커지는 경향이 있다. 어떤 지점에 다다르면 모델 전체를 가지고 이야기하는 것이 힘들어지고 작은 부분들 간의 관계나 상호작용을 이해하기도 어려워진다.

이러한 이유로 인해, 모델은 모듈로 나누어 구조화할 필요가 있다. **모듈화란, 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 기법이다.**

**대규모 모델일지라도 모델에 속해 있는 모듈과 이들 간의 관계를 중심으로 본다면 그 개요를 파악하기 쉬워진다. 모듈들 간의 상호작용이 이해되었다면 그때부터 모듈 하나하나의 내부를 파악하기 시작하면 된다.**

*이 방법으로 소스코드를 읽어야 한다.*

모듈을 사용하는 또 다른 이유는 코드의 품질 때문이다. 코드가 높은 응짐도와 낮은 결합도를 추구해야 한다는 사실은 이미 널리 알려진 사실이다.

### 정리

이런 방법론이나 패러다임에 대한 책을 읽다보면 좋은 것은 알겠으나 실제로 적용 가능한가? 에 대해서는 결국 성숙한 팀으로 귀결되는 것 같다. 10명과 일을 한다면 9명 중 1명만 이에 대해서 부정적이거나 관심이 없다면 생산성이 크게 떨어질 것 같다는 생각이다.

모두를 설득시키는 비용 또한 매우 쎄고 팀 마다 다르고 회사마다 다를 것이다. 이상적인 내용이지만 그 만큼 팀의 수준이 높을 경우 퍼포먼스가 뛰어날 것 같다.

### 논의사항

