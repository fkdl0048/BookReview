## 2장 추상화 계층

> 코드 작성의 목적은 문제해결이다.

### 논의 사항

함수부분과 클래스부분을 읽으며 좀 더 극단적으로 가게된다면 함수형 프로그래밍으로 이어질 것 같다는 생각이 듭니다.  
명확한 차이점이 있겠지만 다른 분들이 느끼는 차이점이 궁금합니다.  
### 책의 내용 및 정리  

핵심 주제  
* 깔끔한 추상화 계층을 통해 문제를 하위 문제로 세분화하는 방법
* 추상화 계층이 코드 품질의 요소를 달성하는 데 어떻게 도움이 되는지
* API 및 구현 세부 사항
* 함수, 클래스 및 인터페이스를 사용해 코드를 추상화 계층으로 나누는 방법  

#### 문제의 단위  

상위 수준의 문제를 해결하기 위해선 여러개의 작은 하위 문제들이 필요하다.  

범용적인 내용인 것 같다.  

일을 처리함에 있어서 단위를 나누는게 마치 인터페이스로 세분화하여서 모듈화를 목적에 두는? 일상 생활도 마찬가지라는 생각이 든다.  

멘토링에서 처리해야 하는 일에 대해서 시간 단위로 일을 처리함을 물어보았는데 일에 단위를 시간으로 계산하기 보다 난이도로 결정하는게 좋을 것 같다고 하셨다.  

난이도를 [1 3 5 7]정도로 구분한다면 미리 쌓아둔 데이트를 기반으로 나누고 5, 7의 경우 다시 1 3 5정도로 세분화를 하는 것이다.  

하루 일에 대한 형태가 대충 트리형태로 그려지는 방법이였는데 매우 좋은 방법인것 같다.

그렇다고 해서 극단적인 세분화또한 독인 것 같다..(스스로 1 3 5 7에 대한 설계가 되어야함,, 0.2 0.1 이런 수준 x)  

#### 추상화 계층 구축의 장점  

1. 가독성: 코드베이스의 모든 세부사항을 이해하는 것은 불가능하지만 몇가지 높은 계층의 추상화를 이해하고 사용하는 것은 상당히 쉽다. 깨끗하고 뚜렷한 추상화 계층은 적은 개념을 다루기만 할 수 있다.  
2. 모듈화: 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 쉬워진다.
3. 재사용성 및 일반화: 하위 문제에 대한 간결한 추상화 계층으로 제시되면 하위 문제에 대한 재사용하기 쉬워진다. 그리고 문제가 적절한 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.
4. 테스트 용이성: 하위 문제에 대한 해결책이 견고한지 테스트를 해야하는데 코드가 추상화 계층으로 깨긋하게 분할되면 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 쉬워진다.  

계속 같은 목적을 이야기 하니까 슬슬 어느정도 청사진이 그려지는 것 같다.. 좋은 코드, 클린코드를 가지기 위해서 좀 더 생각해보고 지금까지 만든 코드를 반면교사로 삼아야겠다..
#### API(application programming interface)  

코드를 작성할 때 고려해야 하는 측면이 두가지가 있다.  

1. 코드를 호출할 때 볼 수 있는 내용
2. 코드를 호출할 때 볼 수 없는 내용

볼 수 있는 내용은 공개수준을 따라간다.  

* 퍼블릭 클래스, 인터페이스 및 메서드  
* 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 **개념**  
* 코드 호출 시 코드를 올바르게 사용하기 위해서 알아야 하는 정보  

반대로 볼 수 없는 내용은 **구현 세부 사항**이다.  

private아래 가려진 내부 함수와 변수들은 구현 세부 사항에 속하며 의존 하는 것 또한 세부 사항이다.  

++ public 메서드라고 해도 이름, 반환값, 인수, 문서를 제외한 함수 내부는 세부사항이다.  

#### 함수  

정말 객체지향에서 함수가 가져야 하는 기본적인 성격에 대해서 쉬운 기준을 보여주며 설명하지만 막상 내가 할 땐 왜이렇게 어려운지 모르겠다.  

지키겠다고 생각하지 않고 급하게 개발을 해서 결과물 위주의 코딩을 반복해서 그런 것 같다.  

읽기 좋은 함수를 짜고 확장성에 용이하고, 모듈화, 재사용성/일반화가 높은 수준의 함수를 요구한다.  

막상 그러한 함수를 짜더라도 어느정도 커플링이 존재하기 때문에 점점 거대해지는 것 같다..  

시간이 아주 조금 더 걸리더라도 헬퍼클래스로 빼거나 함수를 분리해야하는 정신이 필요하다.  

최종적으로는 글을 읽듯이 함수를 순차적으로 읽을 수 있게 되는게 현재로서는 가장 나에게 필요한 형태인듯 하다.

#### 클래스  

단일 클래스에 대한 크기는 정말 밭을 가는 행위인 것 같다.  

초장에 쉽게 갈려고 대충 갈고 농작물을 심어도 이후에 2배 3배로 고생하니 추상적 관계에 대해서 다시 고민하게 된다.  

위와 같은 과정을 이미 여러번 직면해보니 꼭 필요한 과정이라고 생각한다.  

왜 처음부터 구조를 생각해야 하는지 그 프로젝트를 보고 그 중간점을 찾는게 경험에서 나오는 능력인 것 같다.  

지금 진행중인 프로젝트를 열어보니 가장 긴줄이 700줄 정도가 되는 클래스라니..  

이걸 처음부터 수정을 할 생각을 해보기도 했지만 멘토님이 그 비용을 잘 생각해보고 이후에 좋은 반면교사로 활용해서 들고다니면 좋을 것이라는 이야기를 듣고 사이드 이펙트나 문제가 될만한 부분만 수정하고 그대로 두고 프로젝트를 마감할 생각이다..  

책에서 말하는 300줄의 경우 절대적인 지표가 될 수 없지만 경고의 역할이 좋아보인다.  

자신의 코드를 비판적으로 바라볼 때 줄수또한 좋은 지표가 되지 않을까.. (그렇다고 닌자코드나 줄 수를 줄이라는 노력이 아닌 것을 안다. 설계단계의 기준)  

> 한 클래스는 오직 한 가지 일에만 관심을 가져야 한다.  
> 클래스는 응집력이 있어야만 한다.  

위와 같이 `좋은 코드`를 위한 지표도 존재하지만 책에선 근본적인 핵심을 먼저 이행하길 권한다.  

1. 코드 가독성: 단일 클래스에 담겨 있는 개념이 많을수록 해당 클래스의 가독성은 저하된다. 인간은 기본적으로 멀티에 약하다. 자신도 이해하기 힘든 코드는 남들이 볼 땐 2~3배 읽기 힘들 것이라는 사실을 알아야 한다.  

사람들이 3줄요약을 좋아하는 이유도 비슷한 이유일 것.  

2. 코드 모듈화: 클래스 및 인터페이스의 사용은 코드 모듈화를 위한 좋은 방법 중 하나이다. 하위 문제에 대한 해결책이 하나의 클래스로 구현되어 있고, 다른 클래스와의 상호작용을 준비된 퍼블릭 메서드로만 이루어진다면 해결책에 대한 문제가 발생했을 때 쉽게 교체가 가능해진다. 말그대로 부품정도로..  

3. 코드 재사용성 및 일반화: 어떤 문제를 해결할 때 두 가지 하위 문제를 해결해야 하는 경우, 두가지 문제에 대한 해결책을 한 클래스로 묶어 둔다면 이후에 한가지 문제가 발생해도 다른 한가지 해결책을 사용할 기회가 줄어든다..  

4. 테스트 용이성 및 적절한 테스트: 마찬가지로 하위단위로 세분화가 된다면 테스트의 용이성으로 이어진다.  

#### 인터페이스  

인터페이스는 추상화 계층을 깔끔하게 구현하는 코드를 만드는데 있어 매우 유용한 도구이다.  

주어진 하위 문제에 대해 두가지 이상의 서로 다른 구헌이 가능해지고 이를 통해 모듈화를 실현할 수 있다.  

**하나의 인터페이스 및 단일 구현**  

인터페이스를 구현하는 클래스가 유일하다고 해도 이는 매우 유리하게 작용한다.  

**장점**

1. public API를 명확하게 보여준다.  

인터페이스를 상속받은 클래스가 인자로 사용하게 된다면 해당 클래스에 퍼블릭함수를 추가하더라도 상위 클래스는 인터페이스만을 의존하기 때문에 해당 퍼블릭함수는 노출이 되지 않는다.  

2. 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다.  

원래 코드를 작성할 때는 또 다른 구현이 필요하지않을 것이라는 확신을 하더라도 한 두달 후엔 후회할 수 있다  

3. 테스트를 쉽게 할 수 있다.  

구현 클래스가 복잡하거나 네트워크 I/O에 의존하는 경우 목이나 페이크객체로 대체할 수 있다.  

4. 같은 클래스로 두 가지 하위 문제를 해결 할 수 있다.  

한 클래스가 두 개 이상의 서로 다른 추상화계층에 구현을 제공할 수 있다.  

장점이 있다면 단점도 물론이다.  

**단점**

1. 더 많은 작업이 필요하다.  

말 그대로 인터페이스를 정의할려면 코드를 더 작성해야 한다.(생각도 더 해야한다.)  

2. 코드가 복잡해질 수 있다.  

다른 개발자가 코드를 볼 때 하위 문제를 이해하기 위해선 클래스가 아닌 인터페이스 먼저 봐야한다.(해당 인터페이스를 구현하는 클래스를 봐야댐)  

> 인터페이스만을 위한 인터페이스를 작성해서는 안된다.  

이러한 단점도 존재하지만 장점도 명확하기 때문에 이 또한 절충점(선)을 잘 찾아야 할 것 같다.  

기본적인 스탠스로 클래스를 설계할 때 인터페이스를 붙이는 것이 어렵지 않게 설계해야 한다.  

> 너무 비대한 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다. 확실하지 않은 경우에는 남용의 위협에도 불구하고 계층을 얇게 만드는 것이 좋다  

### 느낀점  

클래스를 많이 만드는 것에 대한 **무서움**을 줄여보자..(무작정 많이 만드는 것이 아닌 설계에 따라서)

과연 내가 많이 만드는 것에 대한 무서움을 느낀 것인지 그냥 귀찮아서 인지는 아직까지 잘 모르겠다.  

읽다보니 많이 부끄러워지기도 하고 개발을 1년하고 그만두는게 아니니까.. 문제점을 제대로 직면했다는 것이 중요하다.  

이번 챕터는 실제로 코드를 작성해보고 저자가 소개한 다양한 방법을 적용해보기 좋은 것 같다. 매우매우  

일단 기억나는대로 룰을 지켜가며 코딩한 뒤 다시 가독성, 모듈화, 재사용/일반화, 테스트 용이성을 토대로 비판적인 시각으로 바라보면 답이 쉽게 나올 것 같다.  

아직은 DI나 인터페이스자체를 상속, 인터페이스를 가지는 인터페이스등 다양하게 활용 경험이 없어서 조금 어려운 부분이 있다.  

내용을 정리해보며 공부하고 다시 포스팅 예정

개념은 잡힌 상태지만 활용아직 미숙..