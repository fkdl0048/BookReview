## 3부 개인 행위로 보는 프로그래밍

> 나는 이름을 붙일 가치가 있는 자유는  
> 개인에게 잠재된 물질적, 지적, 정신적 능력을 최대한 개발할 자유뿐  
> 이라고 생각한다. 그 자유에 다른 제한은 없다.  
> 오직 우리의 본성이 정한 법칙에 따를 뿐이다.  
> 다시 말하면, 사실 제한이 전혀 없다고 할 수 있다.  
> : 미하일 바쿠닌

앞 장의 내용에서 프로그래밍 성과가 프로그래머마다 차이가 나는 원인으로 대부분 사회적인 요인에 기인한 것으로 설명했다. 그러나 대부분을 사회적 요인으로 돌린다 하더라도 여전히 남는 부분이 있다. 두 프로그래밍 구조가 아무리 비슷하더라도 최종 결과물은 다를 것이다. 이 차이를 개인에 관련된 여러 요인으로 설명한다.

실험을 수행하는 심리학자는 제일 먼저 모든 실험대상에게 같은 임무를 주었는지를 자문해야 한다. 아무리 잘 통제된 실험일지라도 실험대상에게 주어진 입무에는 많은 차이가 있기 마련이다. 또한 의미있는 결론을 얻기 위해선 임무의 차이를 먼저 찾아야 한다. 프로그래밍 입무는 여러 가지 측면에서 서로 매우 다르다. 따라서 제일 먼저 살펴볼 부분은 **프로그래밍 임무 간의 차이**다.

실험의 목적에 따라 달라지는데, 대상간의 개인차를 측정함이 목표라면 모든 실험 환경을 동일하게 만들어 환경이 유발하는 차이를 막아야 한다. (앞서 환경의 차이가 주는 내용을 학습했다.) 온도, 파티션등 실험 대상의 측정 목적에 영향을 줄 수 있는 모든 환경은 통일해야 한다.

반대로 측정하고자 하는 것이 온도나 환경에 의한 것이라면 그에 대한 차이를 제외한 나머지 요소를 똑같이 조성해야 한다.(업무, 시간 등등)

3부에서는 심리학자가 말하는 이런 개인차를 몇 가지로 나누어 다룬다. 두 사람에게 동일한 환경과 임무를 준다면 각 개인이 보이는 행동의 차이는 이요인들에 의해 나타난다고 간주하는 것이다. 따라서 우리가 관심을 가져아 할 개인차는 크게 **개성, 지능, 훈련 또는 경험**으로 분류할 수 있다.

*물론 모든 것이 환경적인 요인에 의해 결정되는 것은 아니지만, 환경적인 요소에 따라 달라지는 내용이 많기 때문에, 이를 조심해야 한다. (총균쇠)*

### 7장 프로그래밍 작업의 다양성

프로그래밍이란 단어는 무수히 많은 행위를 포괄한다. 단순하게 고등학생이 코드를 적는것 과 작업 프로그래머가 특수 목적의 온라인 컴퓨터를 위해 될수록 용량이 적은 프로그램을 개발하려 노력하는 것도 역시 프로그래밍이다.

#### 프로그래밍의 프로와 아마추어

위에서 다룬 고등학생과 프로 프로그래머의 프로그래머 스펙트럼의 양 극단을 대표한다고 하자. 이 양 극단은 다를 수도 혹은 같을 수도 있다. 그러나 프로가 아마추어보다 프로그래밍에 대해 더 많이 공부하고 실습했음은 분명하다. (차이가 없는 경우도 존재하지만 대부분의 경우 차이가 존재한다.)

가장 큰 차이는 누가 그 프로그램을 사용할 것이냐에 있을 것이다. 아마추어는 자신만이 사용할 요량으로 프로그램을 만든다. 그러나 프로는 다른 누군가가 사용할 프로그램을 만든다. 물론, 프로도 자신만 쓸 프로그램을 만들기도 한다.

이 차이는 실제로 다른 사람이 그 프로그램을 사용할 때 나타나며, 다른 사람이 실제로 사용한다는 점이 프로그래머 작업에 여러가지 영향을 미친다.

아마추어는 문제를 단순하게 만들어 버리거나 정의하는 사람이 본인일 수 밖에 없다. 프로는 자리에서 일어나 프로그램 수정을 허락하거나 요구 명세를 명확히 규정해 줄 다른 사람을 찾아가야 하기 때문이다.

심지어 프로그램 개발을 마친 후의 일은 더 간단하다. 아마추어는 그냥 잊어버리면 끝인 반면에, 프로는 프로그램을 잘 포장하여 냉혹한 세상으로 내보내야 한다. 그 후에는 자신에게 돌아오는 신랄한 비판에 따라 프로그램을 여러모로 수정해야 한다.

- 과연 관리자는 프로그래밍에 대해서 알아야 하는가?
  - 과거에 비해선 현대에선 과정에 대한 이해는 필요하다고 생각한다.

아마추어는 주어진 문제에 대해 배운다. 그리고 그가 배운 것은 뽐낼 만한 장식이 될 수도 있고 발전의 장애가 될 수도 있다. 반면에, 프로는 자신의 직업에 대해 배운다. 지금 다루는 문제는 그가 발전하는 과정의 한 단계일 뿐이다.

또한, 프로는 어떤 문제도 아마추어만큼 심각하게 생각하지 않는다. 그에게는 항상 버그가 있었고 앞으로도 그럴 것이기 때문이다. 이런 태도의 차이는 프로와 아마추어 간의 끊임없는 마찰로 이어진다.

#### 프로그래머가 하려는 것이 무엇인가?

아마추어와 프로의 관계에는 불균형이 있다. 아마추어는 프로가 직면하는 복잡성을 이해할 수 없기 때문이다. 그런데 프로도 아마추어의 작품을 전문성이 떨어진다고 비웃는 우를 자주 범한다. (매우 위험) 이는 아마추어가 자신과 프로의 차이를 과소평가하는 것보다 더한 잘못이다.

프로는 아마추어보다 훨씬 잘 알아야 한다. 아마추어는 우아한 에러 처리 루틴을 만들지 못할 수도 있다. 어떻게 만드는지 혹은 에러 처리 루틴이 무엇인지조차 모를 수 있다. 그러나 **그에게 필요하지도 않은데 꼭 알아야 하는가?** 아마추어가 그런 걸 모르는 것보다는, 프로가 개인적인 용도로 만든 작은 프로그램을 마치 수천 명의 사람이 5 내지 10년 동안 사용할 운영체제인 듯 대하려 하는 쪽이 더 나쁘다.

*개인적인 경험으로도 당장 필요하지 않은 기술, 내용을 학습한 것에 대해서는 정말 도움이 되지 않은 것 같다.*

프로그램은 사람이 만드는 다른 모든 물건처럼 명확한 수명과 활용 범위를 염두에 두고 설계된다. **수백 년 동안 유지될 수 있을 만큼 논리적인 방법으로 만든 장인의 작품**처럼, 프로그램에는 과도하게 설계된 부분도 미진하게 설계된 부분도 있어서는 안 된다.

실제로 환경이 성과에 미치는 영향을 알아보기 위해 실험을 통해 알아본다.

효율성을 추구하는 그룹은 더 많은 컴퓨터 시간과 개인 시간을 사용한 원인은 예기치 않은 어려움에 부딪혔을 때 대처하는 방식의 차이가 큰 요인임을 발견했다. 빨리 완성하려는 그룹은 현재의 수단이 동작하지 않으면 버리고 다른 수단을 찾는다. 그러나 효율성을 추구하는 그룹은 어려움이 생겨도 접근 방법을 바꾸려고 하지 않는다.

따라서 양 그룹의 두 프로그래머가 처음에는 같은 접근 방법을 머릿속에 그리고 있었다 할지라도, 빨리 완성하는 것이 목표인 프로그래머는 전혀 다른 방법으로 끝을 맺는다.

실제 어려움의 원인이 결과와 다소 관계가 없다는 점도 중요하다. 예를 들어 컴파일러의 어떤 버그로 인해 여러 접근법 중 한 가지를 못 쓰는 상황이라고 하자. 그런 상황에서 **빨리 완성하는 것이 목표인 그룹은 문제가 컴파일러 버그로 판명나기도 전에 이미 그 접근법을 포기한다.** **반면에 효율성을 추구하는 그룹은 그 문제를 끝까지 파헤쳐 어쩔 수 없음을 알게 될 때까지 포기하지 않는다.**

심리학 관점에서는 동일한 객관적 사건이라 할지라도 프로젝트의 목표에 따라 사건이 프로젝트에 미치는 영향은 다르다. 따라서 프로그래머의 성과를 측정하거나 언어, 운영체제의 성능을 비교하려면 주어진 문제가 정확히 동일함이 보장되어야 한다.

물론, 실생활에서 두 그룹이 정확히 동일한 문제를 동시에 다루고 있는 경우는 없다고 할 수 있다. 따라서 한 그룹 내의 관리자와 프로그래머들이 전혀 다른 목표를 추구하고 있더라도 그 사실을 인지할 수 없을지도 모른다. **결론적으로, 끊임없이 의사소통하여 목표를 공유하지 않는다면 일정이 지연된다거나 프로그램의 속도가 느리거나 메모리를 많이 사용하는 등의 문제가 생긴다 해도 놀라지 말아야 한다.**

그러나 인생은 그렇게 간단하지 않다. 목표를 아무리 잘 공유해도 어느 정도의 위험은 피할 수 없다. 목표가 추정에 영향을 주기 때문이다. 앞의 실험에서 우리는 목표가 성과에 미치는 영향을 발견한 다시 확인한 결과로 알 수 있다.

최대한 빨리 완성하기를 요구 받은 프로그래머들이 상대적으로 훨씬 보수적인 추정치를 제시했다. 그리고 자신의 추정보다 더 나은 성과를 보였고, 효율적인 프로그램을 요구 받은 쪽과 비교해서도 더 나았다.(낙관적인 것을 제외해도)

*신기하게 빠른 완성을 요구 받은 팀은 시간 추정을 거부하는 반응을 보였다.*

여기서 목표를 명확하게 수립하면 생기는 두 가지 영향을 잘 알아봐야 하는데, 첫 째는 프로그래머는 다른 목표를 희생해서라도 그 명확한 목표를 달성하려 한다. 두번 째는 그 목표를 얼마나 잘 충족시킬지를 **훨씬 더 보수적으로 추정**한다.(또는 정확하게) 강조되지 않은 목표에 대해 프로그래머가 제시한 추정치는 믿을 게 못 된다.

이러한 실험의 결과가 일반적임을 증명한다면, 파킨슨의 법칙이 주는 의혹을 해소할 수 있고 동시에 수많은 관리자들을 악몽에서 구원할 수 있을 것이다. 파킨슨이 "일은 주어진 시간을 다 채울 때까지 늘어난다"고 말한 덕분에 우리는 목표 일정의 존재가 업무 능률에 영향을 준다는 걸 알게 됐다.

그러나 이제 우리는 목표 일정이 주어진 시간 자체에 영향을 준다는 것을 확인했다. **일이 주어진 시간을 다 채울 때까지 늘어날 수 있는 이유는 일정에 대한 다른 목표들의 상대적 중요성이 명확하지 않기 때문이다.** 이런 식으로 사유해 나가면 "프로그래밍 프로젝트는 제때에 끝날 수 없다"는 통념을 낳은 오해들을 불식시킬 수 있을 것이다.

#### 프로그래밍 작업의 단계

이번에는 또 다른 오해, "프로그래밍은 단일한 재능이 요구되는 단일한 작업이다"라는 통념에 대해서 알아보자.

적어도 프로는, 요구 명세 수집에서부터 최종 프로그램 납품에 이르는 과정 동안에 다양한 재능이 필요한 다양한 작업을 해야 한다.

적절하게 조직된 프로젝트에서는 프로그램 개발의 전 과정에 필요한 모든 재능을 모든 프로그래머에게 요구하지 않는다. 개인의 능력에 맞춰 업무를 할당하기 때문이다. 실제로 프로그래밍 작업의 한 단계에 적합한 어떤 재능이 다른 단계에서는 결점이 되기도 한다.

능력 있는 프로그래머가 관리자로는 실패할 수도 있는 것처럼, 훌륭한 설계자도 디버깅에는 서투를 수 있다. 반면에 디버깅에 큰 도움이 되는 사람이 설계 작업 동안에는 필요 없거나, 심지어 방해가 되는 어떤 재능으로 인해 프로젝트에서 제외될 수도 있다.

*앞서 말한 때에 따라 팀장이 바껴야 하는 이유*

적재잭소에 필요한 재능을 투입하려면, 프로그래밍 작업을 단순히 프로그래밍이란 한마디로 싸잡을 것이 아니라 더 정밀하게 세분화해야 한다.

일반적으로 프로그래밍은 문제 정의와 분석, 흐름도 작성, 코딩, 테스트, 문서화로 이어지는 일련의 과정으로 묘사된다. 이런 개략적인 관점에도 일말의 진실이 있기는 하지만, 몇 가지 점에서 진실을 왜곡한다.

우선, 작업의 순서가 그렇게 고정되어 있지는 않다. 예를 들어, 문서화가 테스트나 코딩, 흐름도 작성, 때로는 분석보다도 앞설 수 있다. 둘째, 기존 프로그램을 새로운 플랫폼이나 언어로 포팅하는 경우에서 보듯이 모든 단계가 항상 필요하지는 않다. 셋째, 각 과정을 꼭 일차원적으로 진행할 필요는 없다.

프로그래밍을 심리학적인 관점에서 연구하려면 이런 복잡한 행위들을 좀 더 간단한 단위로 분해해야 한다. 그러나 프로그래밍 과정은 순환적(또는 반복적)이므로 앞서 제시한 분류도 지나치게 정제한 것이다. 각 범주의 경계가 모호하거나 심지어 아예 구별되지 않기 때문이다.

