## 8. 프레임워크 및 재사용: 인터페이스와 추상 클래스를 사용해 설계하기

인터페이스와 프로토콜 및 추상클래스라는 개념들을 확장한다.

인터페이스와 프로토콜 및 추상 클래스는 코드 재사용을 위한 강력한 메커니즘으로 계약이라고 하는 개념의 기초를 제공한다.

### 8.1. 코드: 재사용할 것인가, 사용하지 않을 것인가?

코드를 처음 만들기 시작한 시점부터 지금까지 모든 프로그래머들은 재사용을 위해 코드를 작성하고 있다.

객체지향도 같은 맥락으로 코드를 재사용한다.(객체라는 개념으로)

하지만 앞서 말했듯이 객체지향 패러다임을 따르는 것만이 재사용 가능한 코드를 개발하는 유일한 방법이 아니다.

객체지향이라는 몇 가지 유용한 메커지즘은 있다.

프레임워크를 작성하는 것..!

### 8.2. 프레임워크란?

코드 재사용이라는 개념과 손을 잡을 수 있는 개념으로 표준화라는 개념이 있는데, 이 개념을 `플러그 앤 플레이`라고도 부른다.  

프레임워크(framework)라는 개념은 이러한 플러그 앤 플레이 및 재사용 원칙을 중심으로 한다.

일반적으로 사용하는 오피스군의 애플리케이션또한 같은 디자인을 재사용하거나 같은 기능을 통일시켜둔다.

문서 처리 프레임워크에는 일반적으로 문서 작성, 문서 저장, 텍스트 자르기, 텍스트 복사, 텍스트 붙여넣기, 문서 검색 등의 작업이 포함된다.

이 프레임워크를 사용하려면 개발자가 애플리케이션을 만들 때 사전에 저장된 인터페이스를 사용해야 한다.

이처럼 미리 지정된 인터페이스는 표준 프레임워크를 준수하는데, 이는 두 가지 명백한 장점이 있다.

먼저, 이미 말한 것과 같이 모양과 느낌이 일관되므로 최종 사용자는 프레임워크를 배울 필요가 없다.

둘째, 개발자는 미리 작성하고 테스트까지 한 코드를 활용할 수 있다.(테스트문제는 매우 큰 이점이다.)

새로운 `열기` 대화 상자가 이미 존재하고 철저하게 테스트된 경우에 굳이 새 `열기` 대화 상자를 만드는 코드를 작성할 필요가 있을까?

### 8.3. 계약이란?

계약을 개발자가 API사양을 준수해야 하는 메커니즘으로 생각할 수 있다.

종종 API를 프레임워크라고도 부른다.

> 계약이란, 두 명 이상의 개인 또는 당사자 간의 약속, 특히 법적 구속력이 있는 약속을 말한다.

계약을 사용할 때면 개발자는 프레임워크에 정의된 규칙을 준수해야 한다.

여기에는 메서드 이름, 매개변수의 수 등과 같은 문제가 포함된다.

개발자가 계약을 위반할 수 있기 때문에 이행 강제가 필수적이다.

이행을 강제하지 않으면 불량 개발자는 프레임워크에서 제공하는 사양을 사용하지 않고 바퀴를 다시 발명하는 일에 비유해 볼 수 있는 일, 즉 스스로 코드를 처음부터 작성해버릴 수 있다..

계약을 구현하는 방법은 추상 클래스와 인터페이스를 사용하는 것이다.

#### 8.3.1. 추상 클래스

추상 클래스는 구현부가 없는 메서드가 한 개 이상 들어 있는 클래스다.

Shape라는 추상클래스가 있다고 가정한다면 이 클래스는 인스턴스화할 수 없으므로 추상적인 것이다.

실생활에서는 도형을 그려달라고 요청할 때 먼저 물어볼 것인 "어떤 종류의 도형인가요?"라는 개념도 추상적인 것이다.

이것을 계약에 어떻게 적용할까?

도형을 그리는 애플리케이션을 만든다고 했을 때 해당 애플리케이션의 목표는 현재 설계에 표현된 모든 종류의 도형과 나중에 추가될 수 있는 도형을 그리는 것이다.

먼저 모든 도형이 동일한 구문으로 자신을 스스로 그릴 수 있게하려고 한다.

draw()라는 메서드가 모든 도형에 포함된다면 draw() 메서드를 호출하여 도형을 그릴 수 있다.

다음으로 모든 클래스는 각자 행위에 대해서 책임을 져야 한다는 점을 기억하자.

따라서 어떤 클래스가 draw()라고 불리는 메서드를 제공해야 한다고 하면 해당 클래스는 자체적으로 코드를 구현해야 한다.

따라서 추상 클래스인 Shape가 존재한다면 Circle는 Shape의 확장(즉, 상속)이고 Circle은 draw() 메서드를 구현해야 한다.

이는 계약이라고 볼 수 있다.

*Circle이 draw()를 구현하지 않는다면 컴파일되지 않는다. 따라서 Circle은 Shape와 계약을 지키지 못하는 셈이 된다.*

Circle이 실제로 draw() 메서드를 구현하지 않으면 Circle 자체도 추상체인 것으로 간주한다.

따라서 또 다른 서브 클래스가 상속을 받아 draw() 메서드를 구현해야 한다.

#### 8.3.2. 인터페이스

인터페이스를 정의하기 전에, C++에는 인터페이스라고 하는 컨스트럭트(구성소)가 없다는 점을 알고 간다.

```
인터페이스라는 용어

소프트웨어 용어에서 많이 사용되는 인터페이스라는 용어는 혼동될 수 있다.

1. 그래픽 사용자 인터페이스는 GUI라고 한다.
2. 클래스와 관련해서 인터페이스라는 말은 기본적으로 메서드의 시그니처를 가리킨다.
3. Object-C 및 스위프트에서는 코드를 물리적으로 분리된 모듈로 나누는데, 이 모듈들을 각기 인터페이스와 구현부라고 부른다.
4. 인터페이스와 프로토콜은 기본적으로 부모 클래스와 자식 클래스 간의 계약이다.
```

인터페이스와 동일한 기능을 추상 클래스로 제공할 수 있다면, 왜 굳이 자바와 닷넷에서는 인터페이스라고 부르는 컨스트럭트를 제공하려 하는가?

Object-C와 스위프트에서는 왜 굳이 프로토콜을 제공하는가?

우선 C++은 다중 상속을 지원하지만 자바와 닷넷은 지원하지 않는다.

자바와 닷넷 Object-C 및 스위프트의 클래스들은 하나의 부모 클래스에서만 상속할 수 있지만, 많은 인터페이스를 구현할 수 있다.

*따로는 상속을 구현 상속이라고 하며, 인터페이스는 정의 상속이라고 부른다.*

#### 8.3.3. 종합

추상 클래스와 인터페이스가 모두 추상 메서드를 제공하는 경우에 두 클래스의 실질적인 차이점은 무엇일까?

추상 클래스는 추상 메서드와 구성 메서드를 모두 포함할 수 있지만, 인터페이스는 추상 메서드만 포함할 수 있다.

나중에 더 많은 포유류(mammal)를 추가할 목적으로 개를 대표하는 클래스를 설계한다고 가정한다면 논리적으로 mammal 클래스는 추상 클래스가 되어야 한다.

```java
public abstract class Mammal {
    public void generateHeat() {System.out.println("Generating heat");}
    public abstract void makeNoise();
}
```

이 클래스는 추상 메서드인 makeNoise()와 구성 메서드인 generateHeat()를 모두 포함한다.

모든 포유류는 공통적으로 온기를 내뿜기 때문에 generateHeat() 메서드는 구상적이어야 한다.

그러나 포유류는 다양한 소리를 낼 수 있으므로 makeNoise() 메서드는 추상적이어야 한다.

좀 더 합성, 상속, 인터페이스관계를 알아본다.

```java
public class Head{
    String size;

    public String getSize() {
        return size;
    }

    public void setSize(String size) {
        this.size = size;
    }
}
```

```java
public interface Nameable {
    public String getName();
    public void setName(String name);
}
```

```java
public class Dog extends Mammal implements Nameable{
    private String name;
    private Head head;

    public void makeNoise() {
        System.out.println("Bark");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

- Dog은 Mammal의 일종이므로 (Dog is-a Mammal)이 관계는 상속이다.
- Dog은 Nameable을 구현하므로 (Dog implements Nameable)이 관계는 인터페이스이다.
- Dog은 Head을 가지고 있으므로 (Dog has-a Head)이 관계는 합성이다.

여기서 Nameable관계도 인터페이스이긴 하지만 여전히 상속되지 않는가?

여기서 인터페이스가 왜 특별한지를 알아야 한다.

이 특별한 차이점을 이해해야 객체지향 설계를 이해할 수 있다.

상속은 is-a 관계가 있을 때 사용하지만, 인터페이스는 그다지 엄격하지 않은 관계에도 사용할 수 있다.

- 개는 포유동물의 일종이다. (is-a)
- 파충류는 포유류의 일종이 아니다. (is not a)

따라서 파충류 클래스는 Mammal 클래스에서 상속할 수 없다.

그러나 인터페이스는 다양한 클래스를 초월한다.

- 개에 이름을 지어줄 수 있다. (nameable)
- 도마뱀에 이름을 지어줄 수 있다. (nameable)

이렇게 전혀 관련 없는 클래스끼리도 인터페이스를 사용하여 관계를 맺을 수 있다.

이것이 추상 클래스와 인터페이스의 근본적인 차이점이다.

추상 클래스는 구현체의 일종인 셈이다. 실제로 Mammal은 generateHeat()라는 구상 메서드를 제공했다.

우리는 어떤 포유류가 있을 지 알지 못하지만, 모든 포유류가 온기를 낸다는 점을 알고 있다.

그러나 인터페이스는 **행위**만 모델링한다.  

인터페이스는 어떠한 구현부도 제공하지 않으며, 행위만 제공한다.

인터페이스로는 연결 관계가 없을 수도 있는 클래스들 간에도 동일한 행위를 지정할 수 있다.

이름을 지어 주는 행위를 개에게 적용할 수 있을 뿐만 아니라 자동차와 행성 등에도 적용할 수 있다.

#### 8.3.4. 컴파일러를 사용해 입증해 보기

인터페이스가 진정한 is-a 관계임을 증명하거나 반증할 수 있을까?

자바나 C#의 경우는 컴파일러가 이 점을 알려준다.

```java
Dog D = new Dog();
Head H = D;
```

이 코드는 오류가 발생한다.

```java
Test.java:6: incompatible types
Head H = D;
```

확실히 Dog가 Head인 것은 아니다.  

우리는 이것을 알고 있을 뿐만 아니라 컴파일러도 이것을 알고 있다.

```java
Dog D = new Dog();
Mammal M = D;
```

이것은 진정한 상속 관계이며, Dog은 Mammal이기 때문에 컴파일러가 이를 허용한다.

```java
Dog D = new Dog();
Nameable N = D;
```

이 코드또한 잘 작동한다.  

따라서 우리는 Dog를 이름을 지닌 존재라고 말해도 된다.

이것은 상속 관계와 인터페이스 관계라는 게 is-a관계를 만들어 낸다는, 간단하지만 효과적인 증거다.

인터페이스 관계가 적절하게 사용된다면 '~과 같은 행위'라는 식으로 해석된다.

물론 'is-a'인 데이터 인터페이스들이 있을 수 있지만, 더 자주 전자 형식을 사용하게 될 것이다.

#### 8.3.5. 계약하기

구현부가 없는 메서드를 추상 클래스나 인터페이스 안에 두는 식을 간단하게 계약을 정의할 수 있다.

계약을 지킬 서브클래스로 설계할 때 부모 클래스나 인터페이스가 구현하지 않은 메서드에 대한 구현부를 서브 클래스가 제공해야만 한다.

앞에서 언듭했듯이 계약의 장점 중 하나는 코딩 규칙을 표준화하는 것이다.

코딩 표준을 사용하지 않을 때 발생하는 일을 예로 들어보자.

```java
public class Planet {
    String planetName;

    public void getPlandetName() {
        return planetName;
    }
}
```

```java
public class Car {
    String carName;

    public void getCarName() {
        return carName;
    }
}
```

```java
public class Dog {
    String dogName;

    public void getDogName() {
        return dogName;
    }
}
```

이러한 클래스를 사용하는 사람이 누구든지 각 인스턴스의 이름을 검색하는 방법을 파악하려면 관련 문서를 보아야 한다는 문제점이 있다.

이래서 Nameable 인터페이스가 필요하다.

이름을 사용하는 모든 유형의 클래스와 계약하자는 말이다.

이렇게 하면 여러 클래스를 사용하는 사용자가 한 클래스를 사용하다가 다른 클래스를 사용해야 할 때 객체의 이름을 지정하기 위해 현재 구문을 파악하지 않아도 된다.

```java
public interface Nameable {
    public void getName();
}

public class Planet implements Nameable {
    String planetName;

    public void getName() {
        return planetName;
    }
}

public class Car implements Nameable {
    String carName;

    public void getName() {
        return carName;
    }
}

public class Dog implements Nameable {
    String dogName;

    public void getName() {
        return dogName;
    }
}
```

여기서 드는 생각은 계약이라는 측면에서 인터페이스는 너무 좋지만, 이것을 이행하지 않는 프로그래머가 있다면 어떻게 될까?

사실 결론은 표준 계약을 위반하는 것은 막을 수 없다는 것이다.

그러나 어떤 경우에는 계약을 어기는 일 때문에 심각한 어려움을 겪게 된다.

*팀, 프로젝트, 회사내에서 판단하는 일이기에*

#### 8.3.6. 시스템 접속점

기본적으로 계약은 코드가 내부로 들어가기 위한 접속점이다.

시스템중에 추상화할 곳이 있다면 어디에서나 계약을 사용할 수 있다.

추상화할 곳을 특정 클래스의 객체들에 연결하는 대신에, 여러분은 계약을 구현하는 객체라면 무엇이든지 연결할 수 있다.

어디에 계약이 유용할지 알고 있어야 하는 건 맞지만, 계약을 남용할 가능성도 있다.
