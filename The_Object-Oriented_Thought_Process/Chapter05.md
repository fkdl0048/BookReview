## 5. 클래스 설계 지침

객체지향 프로그래밍이란 **단일 엔터티인 데이터와 행위를 캡슐화해 완전한 패키지인 클래스**를 만든다는 아이디어에 따른 것이다.  

따라서 클래스는 택시와 같은 논리적 구성요소를 나타내야 한다.

이번 장에선 클래스 설계와 관련하여 몇 가지 제안을 한다..!

### 5.1. 현실 세계 시스템 모델링

객체지향 프로그래밍의 주요 목표 중 하나는 사람들이 실제로 생각하는 방식과 비슷한 방식으로 현실 세계의 시스템을 모델링하는 것이다.  

클래스 설계라는 것은 이러한 모델을 작성하기 위해 동원하는 객체지향적인 방법이다.

객체지향 방식은, 데이터와 행위가 논리적으로 별개의 객체가 되게 하는 구조적 방식이나 하향식방식을 사용하는 대신에, 데이터와 행위가 서로 상호작용할 수 있게 한 객체 안에 두어 캡슐화한다.

이렇게 사고하게 되면 문제를 사건의 연속이라고 생각하거나 별로로 존재하는 데이터 파일에서 작동하는 루틴이라고 생각하지 않는다.

이 사고 방식의 **우아함**은 클래스가 문자 그대로 현실의 객체를 모델링한다는 점과, 이렇게 모델링해 만든 객체가 그 밖의 현실 객체와 상호 작용하는 방식에서 나온다.

이러한 상호 작용은 현실 객체간의 상호 작용과 비슷한 방식으로 발생한다.

앞의 예제와 같이 실제 행위를 나타내는 택시 기사와 택시를 생각해서 모델링한다면 Cab객체와 Cabbie 객체는 데이터와 행위를 캡슐화한 다음에 공개 인터페이스를 통해 서로 상호 작용한다.

*여기서 말하는 이 사고가 정말 중요하다. 객체지향적 시선을 가지는게 어렵지만 한가지를 객체지향 클래스로 구현한다면 상속구조나 인터페이스, 캡슐화 수준을 고려해보는 연습을 하면 도움이 된다..*

객체지향 프로그래밍이 처음으로 대중화되었을 때 구조적 프로그래밍을 하던 많던 많은 프로그래머는 객체지향 프로그래밍으로 전환하기 어려웠다.

구조적 방식으로 프로그래밍을 하던 프로그래머가 저지른 주요 실수 중 하나는 실제로 구조적인 모델을 바탕으로 삼아 함수나 서브루틴을 만듦으로써 결과적으로 행위는 있지만 클래스 데이터가 없는 클래스를 만들었다는 점이다.

이런 방식은 캡슐화의 힘을 사용하지 않았기 때문에 생긴 것으로 바람직하지 않다.

*실제로 많은 프로그래머가 객체지향언어를 시작하며 배워온 구조적 프로그래밍 방식을 객체지향언어에 적용하면서 많이 발생하는 문제점이다.*

이런 방식은 현재는 부분적으로 이뤄진다.  

현재 빈약한 도메인 모델이라고 할 수 있는 DTO와 뷰를 생성하기에 충분한 데이터가 있는 뷰 모델의 형태을 사용해 개발하는 방식이 많이 도입되었다.

데이터를 다루는 일과 행위들에 더 초점이 맞춰져 왔는데, 이는 인터페이스를 통해 처리된다는 말이기도 한다.

행위를 단일 응답 인터페이스로 캡슐화한 다음에 인터페이스에 코딩하면 코드는 더욱 유연해지고 모듈화되며, 유지보수를 하기가 훨씬 쉬워진다.

### 5.2. 공개 인터페이스 식별

클래스를 설계할 때 가장 중요한 문제는 공개 인터페이스를 최소한으로 유지하는 것이다.  

클래스를 만들기 위한 목적은 유용하고 간결한 것을 제공하는 데 있다.

> 잘 설계된 객체의 인터페이스는 클라이언트가 원하는 서비스를 설명한다

#### 5.2.1. 최소 공개 인터페이스

최소 공개 인터페이스(minimum public interface)를 제공하면 클래스가 가장 간결해진다.  

목표는 사용자에게 작업을 올바르게 수행할 수 있는 정확한 인터페이스를 제공하는 것이다.

공개 인터페이스가 불완전한 경우에(즉, 행위가 누락된 경우) 사용자는 전체 작업을 수행할 수 없다.

공개 인터페이스를 적절하게 제한해 두지 않으면(즉, 사용자가 불필요하거나 위험한 행위에 접근할 수 있는 경우라면) 문제가 발생해 디버깅이 필요할 수 있으며, 시스템 무결성 및 보안 문제가 생길 수 있다.

클래스를 만드는 일은 일종의 업무 계획이므로 설계 과정을 이루는 모든 단계와 마찬가지로 사용자는 테스트 시작 단계부터 테스트의 모든 단계에 걸쳐 반드시 설계에 참여해야 한다.

- 인터페이스 확장
  - 클래스의 공개 인터페이스가 특정 애플리케이션에 충분하지 않더라도 객체 기술을 사용해 이 인터페이스를 확장하고 조정할 수 있다.
  - 요약하자면, 올바르게 설계된 경우라면 기존 클래스를 활용하는 확장 인터페이스가 되도록 새 클래스를 만들 수 있다.
  - 개발자가 상속을 사용해 행위를 추가하기보다 인터페이스를 사용해 행위를 추가해야 하는 이유다.

#### 5.2.2. 구현부 숨기기

공개 인터페이스를 식별하는 일은 클래스 사용자가 중심이 되게 설계해야 하는 문제인 반면에, 구현부는 사용자가 전혀 관여하지 않도록 해야 한다.

*여기서 사용자란, 코드의 실제 동작 과정을 생각하면 된다. 예를 들어 택시 회사의 택시 기사는 택시 객체를 내부 구성으로 가지고 있고 택시의 최소 인터페이스만 사용하여 운전을 한다. 내부 엔진, 기관등을 알 필요가 없다.*

구현부가 사용자에게 필요한 서비스를 제공해야 하는 것은 맞지만, 이러한 서비스가 실제로 어떻게 수행되는지를 사용자에게 투명하게 내비쳐서는 안된다.

**사용자에게 영향을 미치지 않고 구현부가 변경될 수 있는 경우라야 클래스가 최대로 유용해진다.**

이 부분에서 생각해낼 수 있는 부분이 구현부가 변경된다면 해당 행위에 대한 일관성이 보장되는가? 라는 의문이 있을 수 있는데 이는 테스트코드를 생각하면 쉽게 해결된다.

여기서 나온 개념이 TDD라고 생각되는데 도메인에 맞는 테스트 코드를 미리 만들고 기능을 구현한다면 이후에 구현부가 변경되고 해당 인터페이스를 활용하여 테스트를 통과하면 무결성이 보장된다.

다시 말해 행위를 바꿀 수 있게 하는 가장 좋은 방법은 인터페이스와 컴포지션을 사용하는 것이다.

- 고객 vs 사용자
  - 떼로는 소프트웨어를 실제로 사용하는 사람을 사용자가 아닌 고객으로 부르기도 한다.
  - 같은 맥락에서 조직의 일부인 사용자를 내부 고객이라고 부를 수 있다.
  - 사소해 보이는 개념이라고 생각할 수 있지만, 모든 최종 사용자를 실제 고객으로 생각하는 편이 좋다.

### 5.3. 튼튼한 생성자나 소멸자가 되게 설계하기

클래스를 설계할 때 가장 중요한 설계 문제 중 하나는 클래스 생성 방법이다.

무엇보다 생성자는 객체를 초기의 안전한 상태에 두어야 한다.

여기에는 속성 초기화 및 메모리 관리와 같은 문제가 포함된다.

또한, 객체가 기본 조건에 따라 올바르게 생성되어 있는지를 확인해야 한다.

일반적으로 이 기본적인 상황을 처리할 생성자를 제공하는 것이 좋다.

소멸자를 포함하는 대부분의 언어(GC가 있는 언어는 따로 두지 않고 clear정도의 함수로 메모리 관리)는 적절한 정리 함수를 넣어두는 것이 적당하다.

특정한 시점에 메모리를 해제하는 등의 행위..

#### 5.3.1. 생성자 주입

의존성 주입의 한 예로 생성자를 통해 의존성을 주입하여 디커플링을 도모하는 방법이다.  

서비스 클래스를 클래스 내에 두는 것이 아니라 객체를 생성할 때 생성자에 주입한다는 것을 의미한다.

예를 들어 택시 기사는 자신의 먼혀 객체, 무선 정보 객체를 얻을 수 있으며, 택시를 시동하는 키는 생성자를 통해 객체로 전달된다.

이렇게 되면 택시기사는 일반적인 객체가 아닌 생성자에 따라 다른 성격을 가질 수 있다.

### 5.4. 클래스에 대한 오류 처리 설계

생성자를 설계할 때와 마찬가지로 클래스가 오류를 처리하는 방법을 설계하는 일도 무척 중요하다.

#### 5.4.1. 클래스 문서화 및 주석 사용

대부분의 개발자는 코드를 철저히 문서화해야 한다는 점을 알고 있지만, 일반적으로 이런 일에 시간을 내고 싶어하지 않는다.

그러나 **문서화를 잘 하는 좋은 습관이 없이는 훌룡하게 설계하기는 사실상 불가능**하다.

좋은 설계의 가장 중요한 측면 중에 하나는, 클래스 설계이든지 아니면 그 밖의 어떤 설계이든지 간에, 이러한 설계 과정을 신중하게 문서화해야 한다는 점이다.

#### 5.4.2. 협동할 수 있는 객체로 만들기

홀로 쓰이는 클래스가 더의 없다는 점을 확실히 말할 수 있다.

클래스가 한 번만 사용되지 않는 한, 다른 클래스와 상호 작용을 하지 않는 클래스를 굳이 빌드할 이유가 거의 없기 때문이다.  

어떤 한 가지 클래스는 그 밖에 클래스에 서비스한다.  

한편으로 서비스를 받는 클래스가 그 밖의 클래스에 서비스하기도 하고 클래스끼리 서비스하기도 한다.  

### 5.5. 재사용을 고려한 설계

객체는 다른 시스템에서 재사용할 수 있으며, 재사용을 염두에 두고 코드를 작성해야 한다.

클래스를 다양한 시스템에서 사용할 수 있게 하려면 재사용할 일을 염두에 두고 클래스를 설계해야 한다.

설계 과정에서 생각을 많이 해야 하는 이유이다.

*그렇다고 모든 시나리오를 예측히는 것은 불가능하다.*

### 5.6. 확장성을 고려한 설계

클래스에 새로운 기능을 추가하는 일은 기존 클래스를 확장하고 몇 가지 새로운 메서드를 추가하고 다른 클래스의 행위를 수정하는 일처럼 간단할 수 있다.

모든 것을 다시 작성할 필요는 없다. 이때 상속이 필요하다.

Person클래스를 작성하는 일이 이제 막 끝난 경우라면 Employee클래스나 Customer클래스를 작성할 수 있다는 사실을 고려해야 한다.

이런 경우에 Person클래스를 확장 가능(extensible) 클래스라고 부른다.

이런 확장 클래스의 성격으로 작업할 때 필요하지 않은 기능까지 상속되는 경우가 종종 발생하는데 이 부분이 앞에서 논의한 추상화 지침, 수준을 다루는 것이다.

Person클래스에는 개인과 관련된 데이터와 행위만 포함되어야 한다.

그 다음 다른 클래스가 이를 서브클래스로 삼아서 적절한 데이터와 행위를 상속할 수 있다.

SOLID의 원칙 중 한가지는 클래스는 확장할 수 있도록 개방되어야 하지만 수정하는 일에 대해서는 폐쇄되어야 한다는 원칙이 있다.

인터페이스를 사용해 클래스에 코딩을 하면 실시간으로 테스트하고 배포한 코드를 건드리지 않고 데코레이터와 같은 온갖 종류의 패턴을 사용해 필요한 것을 확장할 수 있다.

정적메서드를 사용하게 되면 클래스끼리의 강한 결합이 발생하게 된다.

**정적 메서드는 추상화할 수 없다.**  

**정적 메서드는 흉내낼 수 없다.**

**정적 인터페이스를 제공할 수 없다.**

유일하게 사용 가능할 때는 Helper클래스를 만들 때이다.

#### 5.6.1 알아보기 쉽게 이름을 짓기

이름만 보고도 객체가 무엇을 표현하고 있는지를 알 수 있어야 한다.

이러한 명명 규칙은 종종 여러 조직의 코딩 표준에 의해 결정된다.

*팀 by 팀*

#### 5.6.2. 이식하기 어려운 코드를 추상화하기

이식하기 어려운 코드를 사용해야 하는 시스템을 설계하는 경우에 이런 코드를 클래스에서 뽑아 내어 추상화해야 한다.

추상화한다는 것은 이식하기 어려운 코드를 자체 클래스나 최소한 자체 메서드로 분리한다는 뜻이다.

#### 5.6.3. 객체 복사 및 객체 비교 방식을 제공

객체가 복사 및 비교될 수 있는 가능성이 있기 때문에(뒷장에서 다룸) 그러한 방법을 설계해야 한다.

#### 5.6.4. 범위를 가능한 한 작게 유지

범위를 최대한 작게 유지하면 추상화와 구현부 은닉이 자연스럽게 이뤄진다.

가능한 한 많은 속성과 행위를 지역화를 하는 것이다.

이런 식으로, 클래스를 유지하고 테스트하고 확장하는 편이 훨씬 쉽다.

인터페이스를 사용하면 이런 면이 더 강화된다.

*범위 및 전역 데이터*

> 전역 변수의 범위를 최소화하는 게 좋은 프로그래밍이며, 이는 객체지향에만 국한되지 않는다.  
> 실제로 객체지향 개발 시에는 전역 데이터가 없다.  

### 5.7. 유지보수를 고려한 설계

유용하고 간결한 클래스가 되게 설계하면 유지보수성이 크게 좋아진다.

클래스를 설계할 때 확장성을 염두에 두고 설계하듯이 향후의 유지보수도 염두에 두고 설계해야 한다.

클래스를 설계할 때에는 코드를 관리하기 쉬운 여러 조각으로 작성해 둔 다음에 합성할 수 있게 설계하는 게 바람직하다.

여러 조각으로 나뉜 코드를 유지보수하기가 큰 코드를 유지보수하기보다 쉬운 편이다.

유지보수성을 높이는 가장 좋은 방법 중의 하나는 서로 의존하는 코드를 줄이는 것이다.

커플링, 거버넌스를 줄이는 것이 핵심

처음부터 클래스를 올바르게 설계했다면, **시스템을 변경할 때는 객체의 구현부만 변경**해야 한다.

어떤 식으로든 공개 인터페이스를 변경하지 말아야 한다.

공개 인터페이스를 변경하는 순간 모든 시스템에 파급 효과가 발생한다.

처음부터 연결정도만 설계하고 구현부의 로직을 붙이거나 수정하는 방식을 생각해보게 되는데 과연 그정도 예상능력이 가능할까??

#### 5.7.1. 개발 과정 반복

대부분의 설계 및 프로그래밍의 함수와 마찬가지로 반복적인 과정을 겪는게 바람직하다.

> 모든 코드를 한 번에 작성하지 말아야 한다.

코드 크기를 작게 해서 작성한 다음에 각 단계별로 코드를 빌드하고 테스트하자.

테스트 계획을 잘 짜 놓으면 인터페이스가 충분하지 않은 영역을 빨리 찾아낼 수 있다.

#### 5.7.2. 인터페이스 테스트

인터페이스를 최소한으로 구현한 것을 종종 **스텁**(stubs)이라고 한다.

스텁을 잘 사용하면 실제 코드를 작성하지 않고도 인터페이스를 테스트할 수 있다.

### 5.8. 객체 지속성 사용

객체의 지속성은 많은 객체지향 시스템에서 해결해야 하는 또 다른 문제이다.

지속성(persistence)이란 객체의 상태를 유지한다는 개념이다.  

프로그램을 실행할 때 어떤 방식으로든 객체를 저장하지 않으면 객체가 죽어 버려서 다시는 복구되지 않는다.

### 느낀점

이번 챕터에서 되게 테스트 코드, 오류처리, 클래스 설계에 대한 생각에 대한 생각이 많아지는 것 같다.
