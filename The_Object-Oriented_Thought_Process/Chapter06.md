## 6. 객체를 사용해 설계하기

우리는 제품을 구매하면 그 제품이 정상적으로 작동할 것으로 기대한다.

하지만 모든 제품이 그런 것은 많은 제품이 생산될 때 대부분의 시간과 노력이 설계 단계가 아닌 **공학**단계에 쓰인다는 점이다.

앞 장에선 우수한 클래스를 설계하는 것을 알아봤다면 이번 장은 우수한 시스템을 설계하는 방법을 알아본다.

시스템은 서로 상호 작용하는 클래스들을 가지고 정의할 수 있다.

### 6.1. 설계 지침

진정한 설계 방법론은 한 가지뿐이라는 말은 오해다.

절대적으로 사실이 아니며 설계를 하기 위한 방법 중에 특별히 옳은 방법이나 그른 방법은 없다.

오늘날에도 많은 설계 방법론들이 있으며, 그에 따른 지지자들이 존재한다.

그러나 가장 중요한 문제는 사용할 설계 방식이 아니라 **메서드 사용법을 어떻게 설계**했느냐다.

이런 주제는 단순한 설계 과정을 넘어 전체 소프트웨어 개발 과정을 포괄하도록 확장될 수 있다.

일부 조직은 표준 소프트웨어 개발과정을 따르지 않거나 준수하지 않는다.

좋은 설계를 만드는 데 있어 가장 중요한 요소는 자신과 조직이 편안하게 느끼고 이를 고수하며 계속 개선하는 과정을 찾는 것이다.

아무도 따르지 않는 설계 과정을 구현하는 것은 의미가 없다.

일반적으로 견고한 객체지향 설계 과정에는 다음 단계가 포함된다.

1. 적절한 분석 수행
2. 시스템 설명 작업명세서 개발
3. 이 작업명세서로부터 요구사항 수집
4. 사용자 인터페이스용 프로토타입 개발
5. 클래스 식별
6. 각 클래스의 역할을 결정
7. 다양한 클래스가 서로 상호 작용하는 방식을 결정
8. 만들고자 하는 시스템을 설명하는 고급 모델을 구성

객체지향 개발의 경우에 고급 시스템 모델이 특히 중요하다.

시스템 모델이나 객체 모델은 클래스 다이어그램들과 클래스의 상호 작용들로 이뤄진다.

이 때 표기법으로 UML이 많이 사용되는데 시각적으로 나타내기 유용하다.

*표준으로 자리잡지 못해서 지금은 많이 사용하지 않는 것 같다..*

```
지속적인 설계 과정

최선의 의도와 계획에도 가장 조그만 설계를 하는 경우가 아니라면 설계 과정은 지속적인 반복 과정이다.

제품을 테스트한 후일지라도 설계를 변경해야 할 일이 생긴다.

제품을 변경하거나 기능을 추가하는 일을 확실히 마치는 시점에 도달하는 일은 프로젝트 관리자의 역할이다.

필자는 이렇게 해서 나온 제품이나 설계를 1판이라고 부른다.
```

사용해 볼 만한 설계 방법론은 다양한다.

폭포수 모형이라고 부르는 초기 방법론은 다양한 단계 사이에 엄격한 경계선을 긋는다.

이 경우엔 설계 단계는 구현 단계 이전에 완료되어야 하며, 구현 단계는 테스트 단계 이전에 완료되어야 한다.

사실 이런 방법론은 현실적이지 않다.

현재는 프토로 타이핑, 익스트림 프로그래밍, 애자일, 스크럼 등과 같은 다른 설계 모델에서 진정한 **반복과정**을 촉진하는 데 힘쓰게 한다.

이 모델에서는 설계 단계를 완료하기도 전에 개념을 증명할 목적으로 일부를 구현해 보게 한다.

따라서 요즘에는 잘 사용하지 않는 폭포수 모델이지만 목표는 이해가 된다.

코딩을 시작하기전 완벽하고 철저하게 설계하는 것이 바람직하다고 알고 있다.

설계를 마친 뒤 제품의 출시 국면으로 직행하지 않고 설계 국면을 다시 반복하기로 결정할 수 있다.

이 처럼 설계 과정은 반복적이며, 반복 자체를 피할 수 없다..

그러나 이 반복을 최소한으로 유지해야 한다.

즉, 반복은 불가피하지만 최소한의 설계, 넓은 설계는 필요하다는 것

폭포수 모델의 요구사항을 조기에 식별하고 설계 변경을 최소로 유지하려고 하는 이유를 요약하면 다음과 같다.

- 설계 단계에서 요구사항이나 설계를 변경하는 비용이 구현 단계나 배포 단계에서 그러는 경우보다 상대적으로 적다.
- 구현 단계에서는 설계 변경 비용이 상당히 높다.
- 배포 단계 이후에 설계를 변경하려고 할 때 드는 비용은 첫 번째 항목과 비교할 때 천문학적이다.

마찬가지로, 건축 설계까 완료되기 전에 꿈 같은 집을 짓기 시작하고 싶지 않을 것이다.

실제로 테스트를 통해 버그가 단 하나도 없는 상태를 추구한다고 보면, 소프트웨어를 철저히 테스트하는 일이 불가능할 수 있다.

**그러나 이론상으로는 이것이 항상 목표다.**

우리는 항상 가능한 많은 버그를 제거하려고 노력해야 한다.

교량과 소프트웨어를 직접 비교할 수는 없다.

**그러나** 소프트웨어는 교량 건설과 같은 `더 난해한`공학 분야와 동일한 수준의 공학적 우수성을 위해 노력해야 한다.

품질이 열악한 소프트웨어는 치명적일 수 있다.

*안전 기기에 삽입된 소프트웨어가 그 예이다.*

#### 6.1.1. 적절한 분석 수행

설계를 구축하고 소프트웨어 제품을 생산하는 데에는 다양한 변수가 관련되어 있다.

**사용자는 모든 단계에서 개발자와 협력한다.**

분석 단계에서 사용자와 개발자는 작업 설명, 프로젝트 요구사항 및 실제 프로젝트 수행 여부를 결정하기 위해 적절한 연구 및 분석을 수행해야 한다.

마지막 요점은 조금 놀라운 것처럼 보일 수 있지만 중요하다.

분석 단계 동안이라도 정당한 사유가 있다면 프로젝트를 중단해야 한다.

사람들은 너무나 자주 프로젝트에 애착을 보인다든가, 사내 권력 관계 때문에 어절 수 없이 그때까지 해 오던 방식 그대로 진행하는 경우가 많다.

지금 말하고 있는 이론 소프트웨어의 원칙은 객체지향에만 국한되지 않고 일반적으로 소프트웨어 개발에 적용된다.

#### 6.1.2. 작업명세서 작성

작업명세서는 시스템을 설명하는 문서이다.

요구사항을 결정하는 것이 분석 단계의 궁극적인 목표이지만, 이 시점에서 요구사항은 아직 최종 형식이 아니다.

시스템의 모양과 느낌을 명료하게 알 수 있어야 한다.

#### 6.1.3. 요구사항 수집

소요제기서는 시스템이 어떤 일을 했으면 좋겠다고 사용자가 생각하는 것을 설명하는 문서이다.

소요제기서의 세부 사항 수준까지 고도의 기술을 발휘할 필요는 없지만, 요구사항은 최종 제품에 대한 사용자 요구의 진정한 본질을 나타내기에 충분할 만큼 구체적이어야 한다.

#### 6.1.4. 시스템 프로토타입 제작

사용자와 개발자가 시스템을 쉽게 이해할 수 있게 하는 가장 좋은 방법 중 하나는 프로토 타입을 만드는 것이다.

무엇이든지 프로토타입으로 만들어 볼 수 있다.

그러나 대부분의 사람은 프로토타입을 시뮬레이션된 사용자 인터페이스로 여긴다.

실제 화면과 화면 흐름을 만들면 사람들이 작업할 내용과 시스템의 느낌에 대해 쉽게 알 수 있다.

어쨌든 프로토타입에는 최종 시스템의 모든 기능이 포함되어 있지는 않다.

#### 6.1.5. 클래스 식별

요구사항이 문서화되어 소요제기가 작성되면 클래스를 식별하기 위한 과정에 착수할 수 있다.

소요제기서에 기록된 요구사항을 바탕으로 클래스를 식별하는 방법 중에 모든 명사를 강조 표시하는 것이 편리하다.

이러한 명사는 사람, 장소 및 사물과 같은 객체를 나태내는 경향이 있기 때문이다.

처음부터 모든 클래스를 다 찾아내려고 애쓰지 않도록 한다.

결국 클래스를 추가하거나 제거하면서 설계 전반의 다양한 클래스를 변경해야 하기 때문이다.

앞서 말한 설계 과정은 반복과정임을 잊지 말자.

#### 6.1.6. 클래스 역할 결정

식별한 클래스의 역학은 직접 결정해야 한다.

여기에는 클래스가 저장해야 하는 데이터와 클래스가 수행해야 하는 연산들이 포함된다.

*Employee객체는 급여를 계산하고 해당 계정으로 돈을 이체하는 일을 담당한다. 다양한 급여 요울이나 다양한 은행 계좌 번호를 저장할 수 있다.*

#### 6.1.7. 클래스 간 협력 방식 결정

대부분의 클래스는 분리되어 존재하지 않는다.

클래스는 특정한 책임을 담당해야 하지만, 원하는 것을 얻기 위해 그 밖의 클래스와 상호 작용을 해야 하는 경우가 많다.

그렇기 때문에 클래스 간에 메세지가 오가게 된다.

어떤 클래스에 그 밖의 클래스가 지닌 정보가 필요하거나 특정 클래스가 그 밖에 클래스에 어떤 일을 시키려고 한다면, 해당 클래스가 정보를 제공하거나 일을 대신해 줄 클래스로 메세지를 보내면 된다.

#### 6.1.8. 시스템 설명 클래스 모델 작성

모든 클래스가 결정되고 클래스의 역할과 협동 방식을 나열한 후에는, 전체 시스템을 나타내는 클래스 모델을 합성해 볼 수 있다.  

이러한 클래스 모델은 다양한 클래스가 시스템 내에서 상호 작용하는 방식을 보여준다.

*책에선 UML을 사용*

#### 6.1.9. 사용자 인터페이스 프로토타입을 코드로 작성

설계 과정에서 사용자 인터페이스의 프로토타입을 만들어야 한다.

이 프로토타입은 설계 과정의 반복을 탐색하는 데 도움이 되는 유용한 정보를 제공한다.

> 시스템 사용자에게 사용자 인터페이스는 시스템

### 6.2. 객체 래퍼

필자가 여러번 강조하는 내용으로 객체지향 프로그래밍이 구조적 프로그래밍과 별개의 패터다임이라는 오해를 불식시키는 것이였고, 필자가 그런 오해를 좋아하지 않는다는 점을 나타내는 것이었다.

구조적이지 않게 프로그램을 작성할 수 있는 방법은 없다.

따라서 객체지향 프로그래밍 언어을 사용하고 건전한 객체지향 설계 기술을 사용하는 프로그램을 작성할 때 구조적 프로그래밍 기술도 함께 사용한다.

**이 문제를 해결할 방법은 없다.**

좀 더 예를 들어 설명한다면 속성과 메서드가 포함된 새 객체를 만들면 해당 메서드에 구조적 코드가 포함된다.

사실, 이러한 메서드에는 대부분 구조적 코드가 포함된다고 말할 수도 있다.

이 방법은 이전 장에서 살펴본 컨테이너라는 개념과 잘 맞는다.

실제로 메서드 수준에서 코딩하는 시점에 도달하면 코볼, C 등과 같은 구조적 언어로 프로그래밍하던 시절 이후로도 코딩 사고 과정은 크게 달라지지 않았다.

좀 더 넓게 본다면 내 생각은 언어와 이런 패러다임은 모두 나의 생각을 표현하기 위한 도구에 불과하다.

#### 6.2.1. 구조적 코드

프로그래밍 로직의 기본 상황을 논할 수 있지만, 필자가 강조했듯이, 기본 객체지향 구조는 캡슐화, 상속, 다형성 및 합성으로 이뤄진다.

구조적 프로그래밍을 다루는 다른 책에선 컨스트럭트(구성소), 순서(sequence), 조건(conditions) 및 반복(iterations)이라는 4가지 기본 구조를 설명한다.

순서 부분은 주어진 것으로 상단에서 시작해 하단으로 진행하는 것이 논리적이기 때문이다.

구조적 프로그래밍의 핵심은 조건과 반복에 있다.

#### 6.2.2. 구조적 코드 둘러싸기

속성을 정의하는 일도 코딩으로 간주되지만, 객체의 행위들은 메서드로 정의한다.

그리고 대부분의 코드 로직이 이러한 메서드에 들어 있게 된다.

이 부분은 당연하게 해오던 코딩 방식이지만 필자는 구조적과 객체지향적으로 바라본다.

```java
class SomeMath{
  public int add(int a, int b)
  {
    return a + b;
  }
}
```

add라는 메서드가 있는데 여기서 사용되는 구조적 코드는 `a + b`는 add라는 메서드안에 둘러싸인다.

간단한 예이지만 구조적 코드를 둘러싸기만 하면 된다.

따라서 사용자가 이 방법을 사용하려고 할 때 필요한 것은 다음에 보이는 메서드의 시그니처다.

```java
public class TestMath{
  public static void main(String[] args){
    int x = 0;

    SomeMath math = new SomeMath();
    x = math.add(4, 5);
    System.out.println(x);
  }
}
```

정말 기본적인 형태의 래퍼이다.

#### 6.2.3. 이식하기 어려운 코드를 둘러싸기

객체 래퍼의 또 다른 용도는 이식하기 어려운 코드(네이티브 코드)를 감추기 위함이다.

개념은 본질적으로 동일하다.

그러나 이런 경우의 요점은 오직 하나의 플랫폼에서만 실행할 수 있는 코드를 가져다 사용하는 프로그래머들에게 간단한 인터페이스를 제공하는 메서드로 캡슐화하는 것이다.

> ex) 윈도우 플랫폼의 경고음 코드를 메서드로 캡슐화화여 제공

#### 6.2.4. 기존 클래스를 둘러싸기

기존의 구조적 코드나 이식 불능 코드를 새로운 클래스로 둘러싸야 할 필요는 있지만, 기존 클래스를 둘러싸야 할 필요성은 그리 명백하지 않을 수 있다.

그러나 기존 클래스에 대한 래퍼를 작성해야 하는 이유도 많다.

소프트웨어 개발자는 종종 다른 사람이 작성한 코드를 사용한다.

공급업체에서 구매했거나 조직 내에서 내부적으로 작성한 코드는 변경하기 힘든 경우가 많다.

이런 경우 래퍼를 사용하면 기존 클래스를 변경하지 않고도 기존 클래스의 기능을 확장할 수 있다.

소프트웨어 개발 시에 래퍼를 사용하는 일은 개발자의 관점뿐만 아니라 공급업체의 관점에서도 상당히 광범위하게 행해진다.

**래퍼는 소프트웨어 시스템을 개발할 때 중요한 도구이다.**

### 6.3. 결론

다시한번 강조하지만 객체지향 코드와 구조적 코드는 서로 배타적인 게 아니다.

실제로 우리는 구조적 코드를 사용하지 않으면 객체를 만들 수 없다.

따라서 우리가 객체지향 시스템을 구축하는 과정이라면 이미 설계 시에 구조적 기술을 사용하는 셈이나 마찬가지다.

객체 래퍼는 전통적인 코드와 객체지향적인 코드에서 이식 불능 코드에 이르기까지 다양한 기술을 캡슐화하는 데 사용된다.

객체 래퍼의 주요 목적은 코**드를 사용하는 프로그래머에게 일관된 인터페이스**를 제공하는 것이다.

### 느낀점

이 책은 확실히 객체지향만을 다루지 않는다.

엔지니어로서 소프트웨어를 접하는 마음가짐이나 생각해야하는 사고방식은 물론 객체지향에 대한 오해를 바로잡고자 한다.

래퍼에 대한 생각이 그냥 단순하게 감싸는 용도로 생각했는데 인터페이스 단위나 함수처럼 낮은 레벨의 래퍼까지 생각못해봤다.

당연하게 하고 있는 행동들에 대한 이론을 이제 배운 기분..
