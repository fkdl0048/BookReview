## 11. 의존적이거나 경직된 클래스가 되지 않게 하기

앞 1장에서 다룬 것과 같이 객체지향 프로그래밍의 핵심은 캡슐화, 상속, 다형성, 합성이다.

*인터페이스(접속)도 추가하는 게 좋겠지만 특정 유형의 상속이라고 본다.*

개발자들 사이에서 상속과 합성은 항상 뜨거운 감자이다.

요즘은 상속보단 합성에 좀 더 초점을 두고 상속 자체를 단일 계층 수준이나 2레벨까지만 제한하여 최소하는 경향이 있다.

상속을 사용하는 방법에 초점을 둔 이유는 묶임(coupling) 문제와 관련이 있다.

상속 사용에 대한 논쟁은 거의 재사용성과 확장성 및 다형성에 관해서이지만, 사실상 상속은 클래스들 간에 의존체(dependencies)가 있게 하는 꼴이므로 문제를 일으킬수 있다.

상속과 합성에 익숙해지기에서는 상속이 실제로 캡슐화를 약화시키는 방법에 대해 논의했는데, 이는 기본 개념이기 때문에 직관적이지 않은 것처럼 보인다.

> **주의**  
> 7장에서도 언급된 내용이지만 상속을 피하라는 말이 아니다.  
> 여기서 논의하는 내용은 실제로 의존체들과 묶임성이 강한 클래스들을 피하는 일에 관한 것이다.  
> 상속 사용 시기는 이 논의에서 중요한 부분이다.

그렇다면 상속이 아니라면 무엇을 사용해야 할까?

간단히 말하자면 **합성**이 답이다.  

*다른 책에선 구성으로 표현하기도 한다.*

필자는 전반적으로 클래스를 재사용하는 방법에 대해서 상속과 합성이라는 두 가지 방법만 있다고 주장한다.

상속 방식으로는 부모 클래스에서 자식을 생성할 수 있고, 합성 방식으로는 클래스 내에 그 밖의 클래스들을 넣을 수 있다.

그렇다면 상속을 피해야 한다면 상속을 배우는 대 시간을 소비할 필요가 있을까?

간단히 답하면 많은 코드에서 상속이 사용된다.

대부분 개발자가 곧 이해하겠지만 유지보수 시점에 이르러서야 대부분의 코드에 당면하게 된다.

따라서 상속을 사용해 작성된 코드를 수정하고 개선하고 유지보수하는 방법을 이해해야 한다.

우리가 새로운 코드를 작성할 때 상속을 사용해야 할 수도 있다.

요약하자면, 프로그래머는 가능한 모든 객체지향 기반 기술과 더불어 개발자가 활용해 볼 만한 모든 도구는 배 두는게 좋다는 말이다..

또한, 이 말은 프로그래머가 자신이 활용해 오던 다양한 객체지향 기술이나 객체지향 도구에만 집착하지 말고 새로운 기술과 도구를 익히는 일도 생각해 두어야 한다는 말이기도 하다.

*여기서 필자가 가치 판단을 하고 있지 않다는 점을 이해해야 한다.*

즉, 상속이 문제가 되므로 피해야 한다고 주장하는 게 아니다.

상속이 어떻게 사용되는지를 **완전히** 이해하고 대안적인 설계 방식을 신중하게 연구한 후에 비로소 스스로 결정하는 중요함을 강조하고 있다.

```
생각

책으로만 상속이나 설계에 대해 완벽하게 이해하기는 불가능하다.

내 생각엔 그렇다.. 실제로 샌드박스로 만들어 보거나 프로젝트로 경험하며 감각을 키워야 하는 부분이 존재한다.

이는 시간과 노력이 생각보다 많이 들어간다..
```

따라서 이번 장의 예제는 클래스를 설계하는 최적의 방법을 반드시 설명하려는 의도로 보인 게 아니고 오히려 상속과 합성 사이의 결정과 관련된 문제에 대해 생각하게 하기 위한 훈련용 연습 문제인 것이다.

모든 기술을 발전시키면서 좋은점은 **지키면서도 그다지 좋지 않으면 개선**하는 게 필요하다.

또한, 합성에는 고유한 묶임 문제가 있다.

7장에서 설명한 결합과 응집 즉, 컴포지션에 대한 문제가 있다.

> 응집체는 다른 객체에 포함된 객체이며  
> 결합체는 매개변수 목록을 통해 다른 객체로 전달되는 객체이다.  
> 응집체는 객체에 포함되어 있기 때문에 서로 밀접하게 연결되어 있으므로 피해야 한다.

따라서 상속으로 인해 클래스끼리 서로 강하게 묶인다는 평판이 있었지만, 합성으로도 강하게 묶이는 클래스를 만들 수 있다.

응집체들을 사용해 스테레오를 만드는 일이란 단일 컴포넌트 안에 모든 컴포넌트가 포함된 제품인 CD 카세트를 만드는 일에 비유할 수 있다.

다양한 상황에서 CD 카세트는 무척 편리하다.  

집어 들고 쉽게 움직일 수 있으며, 특별한 조립이 필요하지 않다.  

그러나 이런 식으로 설계하면 많은 문제가 생길 수 있다.

MP3 플레이어가 방가지만 전체 장치를 수리점에 맡겨야 한다.

더 나쁜 것은 전기 문제와 같이 전체 붐 박스를 사용할 수 없게 만드는 많은 문제가 발생할 수 있다.

결합체들을 사용해 스테레오를 만들면 응집체에서 발생하는 많은 문제점을 피할 수 있다.

컴포넌트 음향기기를 연결선으로 연결해 둔 한 뭉치의 결합체들이라고 생각해 보자.

이 설계에는 스피커, CD 플레이어, 턴테이블 및 카세트 플레이어와 같은 다른 여러 객체에 연결된 중심 객체가 있으며, 이것을 리시버라고 부른다.

사실 이 리시버는 제작업체가 어느 곳이든지 별 상관없는 해법이라고 생각할 수 있는데, 상품 진열대에서 이 컴포넌트를 쉽게 구할 수 있기 때문이다.

이 상황에서 CD 플레이어가 고장 나면 CD플레이어만 분리하여 고치거나 작동하는 새 CD 플레이어로 교체할 수 있다.

> 팁  
> 9장에서 말했듯이 강하게 묶이는 클래스는 일반적으로 눈살을 찌푸리게 하는 게 맞기는 해도 때로는 강하게 묶이게 하는 설계로 인한 위험을 감수해야 하는 경우도 있다.  
> CD플레이어가 그 예이며 강하게 묶이게 하는 설계 방식으로 만든 것임에도 때로는 선호되는 선택지이다.

### 11.1. 합성 대 상속, 그리고 의존성 주입

먼저 예제의 상속 모델을 상속이 아니라 합성으로 다시 설계하는 것에 초점을 맞출 것이다.

두 번째로 최적의 솔루션은 아니지만 응집을 사용함에도 합성으로 다시 설계하는 방법을 보여준다.

세 번째는 응집체를 피하고 그 대신에 결합체를 사용해 설계하는 방법을 보여준다.

#### 11.1.1. 상속

```java
class Mammal{
  public void eat() { System.out.println("I am Eating"); }
}

class Bat extends Mammal{
  public void fly() { System.out.println("I am Flying"); }
}

class Dog extends Mammal{
  public void bark() { System.out.println("I am Barking"); }
}

public class TestMammal{
  public static void main(String[] args){

    Dog fido = new Dog();
    fido.eat();
    fido.bark();

    Bat batty = new Bat();
    batty.eat();
    batty.fly();
  }
}
```

이 설계에서 Mammal은 모든 포유류가 무언가를 먹어야만 한다고 가정하므로 eat()라는 단일행위를 갖게 된다.

그러나 우리가 Mammal의 서브클래스인 Bat와 Dog를 추가하게 되면, 즉시 상속 문제가 발생한다.

개는 짖을 수 있지만 모든 포유류가 짖는 것은 아니다. 또한 박쥐는 날 수 있지만 모든 포유류가 날 수 있는 것은 아니다.

문제는 이러한 메서드들이 어디에 속해야 하는가다.

이전의 펭귄 예제에서와 같이 조류라고 해서 다 날 수 있는 게 아니기 때문에 상속 위계구조에서 메서드를 배치할 위치를 경정하는 것은 까다로울 수 있다.

Mammal 클래스를 FlyingMammals와 walkingMammals로 분리하는 방식은 모든 게 드러나지 않은 빙산 중에 한 부분만 드러낼 뿐이므로 아주 우아한 해결책은 아니다.

*진짜 빙산의 일각 그림 너무 공감..*

어떤 포유류는 헤엄칠 수 있고, 어떤 포유류는 알을 넣기도 한다.

더욱이, 개별 포유동물 종이 가지고 있는 수많은 다른 행위가 있을 수 있으며, 이러한 모든 행위에 대해 별도의 클래스를 만드는 일은 비현실적일 수 있다.

이러한 설계는 is-a관계로 접근하는 대신에 has-a 관계를 사용해 설계를 탐색해야 한다.

#### 11.1.2. 합성

이 전략에서는 클래스 자체를 행위를 포함하지 않고 각 행위에 대해 개별 클래스를 만든다.

따라서 상속 위계구조에 행위를 배치하는 대신에 각 행위에 대한 클래스를 만들고 나서는 필요한 행위만 포함함(응집)으로써 개별 포유류를 만들 수 있다.

> **주의**  
> 응집이라는 용어는 앞 단락에서 사용되었다는 점에 유의하자  
> 이번 예제는 상속 대신에 합성을 사용하는 방법이며, 여전히 중요한 묶음 개념이 남아있다.  
> 따라서 인터페이스를 사용해 다음 예제로 나아가는 중간 교육 단계로 생각하자.  

```java
class Mammal{
  public void eat() { System.out.println("I am Eating"); }
}

class Walkable{
  
}
```