## 11. 의존적이거나 경직된 클래스가 되지 않게 하기

앞 1장에서 다룬 것과 같이 객체지향 프로그래밍의 핵심은 캡슐화, 상속, 다형성, 합성이다.

*인터페이스(접속)도 추가하는 게 좋겠지만 특정 유형의 상속이라고 본다.*

개발자들 사이에서 상속과 합성은 항상 뜨거운 감자이다.

요즘은 상속보단 합성에 좀 더 초점을 두고 상속 자체를 단일 계층 수준이나 2레벨까지만 제한하여 최소하는 경향이 있다.

상속을 사용하는 방법에 초점을 둔 이유는 묶임(coupling) 문제와 관련이 있다.

상속 사용에 대한 논쟁은 거의 재사용성과 확장성 및 다형성에 관해서이지만, 사실상 상속은 클래스들 간에 의존체(dependencies)가 있게 하는 꼴이므로 문제를 일으킬수 있다.

상속과 합성에 익숙해지기에서는 상속이 실제로 캡슐화를 약화시키는 방법에 대해 논의했는데, 이는 기본 개념이기 때문에 직관적이지 않은 것처럼 보인다.

> **주의**  
> 7장에서도 언급된 내용이지만 상속을 피하라는 말이 아니다.  
> 여기서 논의하는 내용은 실제로 의존체들과 묶임성이 강한 클래스들을 피하는 일에 관한 것이다.  
> 상속 사용 시기는 이 논의에서 중요한 부분이다.

그렇다면 상속이 아니라면 무엇을 사용해야 할까?

간단히 말하자면 **합성**이 답이다.  

*다른 책에선 구성으로 표현하기도 한다.*

필자는 전반적으로 클래스를 재사용하는 방법에 대해서 상속과 합성이라는 두 가지 방법만 있다고 주장한다.

상속 방식으로는 부모 클래스에서 자식을 생성할 수 있고, 합성 방식으로는 클래스 내에 그 밖의 클래스들을 넣을 수 있다.

그렇다면 상속을 피해야 한다면 상속을 배우는 대 시간을 소비할 필요가 있을까?

간단히 답하면 많은 코드에서 상속이 사용된다.

대부분 개발자가 곧 이해하겠지만 유지보수 시점에 이르러서야 대부분의 코드에 당면하게 된다.

따라서 상속을 사용해 작성된 코드를 수정하고 개선하고 유지보수하는 방법을 이해해야 한다.

우리가 새로운 코드를 작성할 때 상속을 사용해야 할 수도 있다.

요약하자면, 프로그래머는 가능한 모든 객체지향 기반 기술과 더불어 개발자가 활용해 볼 만한 모든 도구는 배 두는게 좋다는 말이다..

또한, 이 말은 프로그래머가 자신이 활용해 오던 다양한 객체지향 기술이나 객체지향 도구에만 집착하지 말고 새로운 기술과 도구를 익히는 일도 생각해 두어야 한다는 말이기도 하다.

*여기서 필자가 가치 판단을 하고 있지 않다는 점을 이해해야 한다.*

즉, 상속이 문제가 되므로 피해야 한다고 주장하는 게 아니다.

상속이 어떻게 사용되는지를 **완전히** 이해하고 대안적인 설계 방식을 신중하게 연구한 후에 비로소 스스로 결정하는 중요함을 강조하고 있다.

```
생각

책으로만 상속이나 설계에 대해 완벽하게 이해하기는 불가능하다.

내 생각엔 그렇다.. 실제로 샌드박스로 만들어 보거나 프로젝트로 경험하며 감각을 키워야 하는 부분이 존재한다.

이는 시간과 노력이 생각보다 많이 들어간다..
```

따라서 이번 장의 예제는 클래스를 설계하는 최적의 방법을 반드시 설명하려는 의도로 보인 게 아니고 오히려 상속과 합성 사이의 결정과 관련된 문제에 대해 생각하게 하기 위한 훈련용 연습 문제인 것이다.

모든 기술을 발전시키면서 좋은점은 **지키면서도 그다지 좋지 않으면 개선**하는 게 필요하다.

또한, 합성에는 고유한 묶임 문제가 있다.

7장에서 설명한 결합과 응집 즉, 컴포지션에 대한 문제가 있다.

> 응집체는 다른 객체에 포함된 객체이며  
> 결합체는 매개변수 목록을 통해 다른 객체로 전달되는 객체이다.  
> 응집체는 객체에 포함되어 있기 때문에 서로 밀접하게 연결되어 있으므로 피해야 한다.

따라서 상속으로 인해 클래스끼리 서로 강하게 묶인다는 평판이 있었지만, 합성으로도 강하게 묶이는 클래스를 만들 수 있다.

응집체들을 사용해 스테레오를 만드는 일이란 단일 컴포넌트 안에 모든 컴포넌트가 포함된 제품인 CD 카세트를 만드는 일에 비유할 수 있다.

다양한 상황에서 CD 카세트는 무척 편리하다.  

집어 들고 쉽게 움직일 수 있으며, 특별한 조립이 필요하지 않다.  

그러나 이런 식으로 설계하면 많은 문제가 생길 수 있다.

MP3 플레이어가 방가지만 전체 장치를 수리점에 맡겨야 한다.

더 나쁜 것은 전기 문제와 같이 전체 붐 박스를 사용할 수 없게 만드는 많은 문제가 발생할 수 있다.

결합체들을 사용해 스테레오를 만들면 응집체에서 발생하는 많은 문제점을 피할 수 있다.

컴포넌트 음향기기를 연결선으로 연결해 둔 한 뭉치의 결합체들이라고 생각해 보자.

이 설계에는 스피커, CD 플레이어, 턴테이블 및 카세트 플레이어와 같은 다른 여러 객체에 연결된 중심 객체가 있으며, 이것을 리시버라고 부른다.

사실 이 리시버는 제작업체가 어느 곳이든지 별 상관없는 해법이라고 생각할 수 있는데, 상품 진열대에서 이 컴포넌트를 쉽게 구할 수 있기 때문이다.

이 상황에서 CD 플레이어가 고장 나면 CD플레이어만 분리하여 고치거나 작동하는 새 CD 플레이어로 교체할 수 있다.

> 팁  
> 9장에서 말했듯이 강하게 묶이는 클래스는 일반적으로 눈살을 찌푸리게 하는 게 맞기는 해도 때로는 강하게 묶이게 하는 설계로 인한 위험을 감수해야 하는 경우도 있다.  
> CD플레이어가 그 예이며 강하게 묶이게 하는 설계 방식으로 만든 것임에도 때로는 선호되는 선택지이다.

### 11.1. 합성 대 상속, 그리고 의존성 주입

먼저 예제의 상속 모델을 상속이 아니라 합성으로 다시 설계하는 것에 초점을 맞출 것이다.

두 번째로 최적의 솔루션은 아니지만 응집을 사용함에도 합성으로 다시 설계하는 방법을 보여준다.

세 번째는 응집체를 피하고 그 대신에 결합체를 사용해 설계하는 방법을 보여준다.

#### 11.1.1. 상속

```java
class Mammal{
  public void eat() { System.out.println("I am Eating"); }
}

class Bat extends Mammal{
  public void fly() { System.out.println("I am Flying"); }
}

class Dog extends Mammal{
  public void bark() { System.out.println("I am Barking"); }
}

public class TestMammal{
  public static void main(String[] args){

    Dog fido = new Dog();
    fido.eat();
    fido.bark();

    Bat batty = new Bat();
    batty.eat();
    batty.fly();
  }
}
```

이 설계에서 Mammal은 모든 포유류가 무언가를 먹어야만 한다고 가정하므로 eat()라는 단일행위를 갖게 된다.

그러나 우리가 Mammal의 서브클래스인 Bat와 Dog를 추가하게 되면, 즉시 상속 문제가 발생한다.

개는 짖을 수 있지만 모든 포유류가 짖는 것은 아니다. 또한 박쥐는 날 수 있지만 모든 포유류가 날 수 있는 것은 아니다.

문제는 이러한 메서드들이 어디에 속해야 하는가다.

이전의 펭귄 예제에서와 같이 조류라고 해서 다 날 수 있는 게 아니기 때문에 상속 위계구조에서 메서드를 배치할 위치를 경정하는 것은 까다로울 수 있다.

Mammal 클래스를 FlyingMammals와 walkingMammals로 분리하는 방식은 모든 게 드러나지 않은 빙산 중에 한 부분만 드러낼 뿐이므로 아주 우아한 해결책은 아니다.

*진짜 빙산의 일각 그림 너무 공감..*

어떤 포유류는 헤엄칠 수 있고, 어떤 포유류는 알을 넣기도 한다.

더욱이, 개별 포유동물 종이 가지고 있는 수많은 다른 행위가 있을 수 있으며, 이러한 모든 행위에 대해 별도의 클래스를 만드는 일은 비현실적일 수 있다.

이러한 설계는 is-a관계로 접근하는 대신에 has-a 관계를 사용해 설계를 탐색해야 한다.

#### 11.1.2. 합성

이 전략에서는 클래스 자체를 행위를 포함하지 않고 각 행위에 대해 개별 클래스를 만든다.

따라서 상속 위계구조에 행위를 배치하는 대신에 각 행위에 대한 클래스를 만들고 나서는 필요한 행위만 포함함(응집)으로써 개별 포유류를 만들 수 있다.

> **주의**  
> 응집이라는 용어는 앞 단락에서 사용되었다는 점에 유의하자  
> 이번 예제는 상속 대신에 합성을 사용하는 방법이며, 여전히 중요한 묶음 개념이 남아있다.  
> 따라서 인터페이스를 사용해 다음 예제로 나아가는 중간 교육 단계로 생각하자.  

```java
class Mammal{
  public void eat() { System.out.println("I am Eating"); }
}

class Walkable{
  public void walk() { System.out.println("I am Walking"); }  
}

class Flyable{
  public void fly() { System.out.println("I am Flying"); }
}

class Dog{
  Mammal dog = new Mammal();
  Walkable walkable = new Walkable();
}

class Bat{
  Mammal bat = new Mammal();
  Flyable flyable = new Flyable();
}

public class TestMammal{
  public static void main(String[] args){

    Dog fido = new Dog();
    fido.dog.eat();
    fido.walkable.walk();

    Bat batty = new Bat();
    batty.bat.eat();
    batty.flyable.fly();
  }
}
```

> **참고**  
> 이번 예제는 상속 대신에 합성을 사용하는 방법을 설명하는 것이다.  
> 설계에 상속을 전혀 사용할 수 없다는 의미가 아니다.  
> 설계 단계에서 모든 포유류가 포식 행위를 한다고 했다면 앞처럼 eat() 메서드를 Mammal 클래스에 추가하는 것이 더 나은 설계일 수 있다.  
> 항상 그렇듯이, 이게 설계 결정이다.  

아마도 이 논의의 핵심은 앞서 다루었던 개념, 상속이 오히려 캡슐화를 깬다는 점일 것이다.  

Mammal 클래스를 변경하게 되면 모든 Mammal 서브클래스를 다시 컴파일해야 하기 때문에 이런 측면을 쉽게 이해할 수 있다.

이는 이와 같은 클래스들이 서로 밀접하게 결합되어 있으며, 클래스를 가능한 한 많이 분리한다는 목표에 반한다는 뜻이다.  

합성의 예제에서 Whale 클래스를 추가한다고 해도 이전에 작성된 클래스 중 어느것도 다시 작성할 필요는 없다.

만약 Swimmable이라는 클래스와 Whale이라는 클래스를 추가한다면 Swimmable 클래스를 Dolphin 클래스에 재사용할 수 있다.

```java
class Swimmable{
  public void swim() { System.out.println("I am Swimming"); }
}

class Whale{
  Mammal whale = new Mammal();
  Swimmable swimmable = new Swimmable();
}
```

기존 애플리케이션은 이전에 존재했던 클래스를 변경하지 않은 채로 이 기능을 추가할 수 있다.

필자의 경험 법칙 중 한가지는 다형성이 꼭 필요한 상황에서만 상속을 사용하라는 것이다.

Shape에서 상속된 Circles와 Rectangle은 상속을 합법적으로 사용하는 것일 수 있다.

반면에, 걷기나 날기와 같은 행위는 상속에 대한 좋은 후보가 아닐 수 있다.

*구현 상속/정의 상속 구분 그리고, 상속은 주로 데이터/모델링 상속, 행위는 주로 구현*

합성을 사용해 이 솔루션을 구현했지만 설계에는 심각한 결함이 있다.

new 키워드를 사용하는 것이 명백하기 때문에 객체가 강하게 묶여 있다.

클래스를 분리하는 연습을 완료하기 위해 의존성 주입이라는 개념을 소개한다.

[의존성 주입 정리글](https://fkdl0048.github.io/patterns/Patterns_DI/)

간단하게 정리하여 객체를 생성하는 대신에 매개변수 목록을 통해 다른 객체 내부로 외부 객체를 주입한다는 뜻이다.

#### 11.1.3. 의존성 주입

이전 단원에 나온 예제에서는 합성을 통해 Dog에게 Wakeable 행위를 제공했다.  

Dog클래스는 문자 그대로 다음 코드 조각과 같이 Dog 클래스 자체 내에 새로운 Walkable 객체를 만들었다.

```java
class Dog{
  Walkable walkable = new Walkable();
}
```

이것은 실제로 동작하지만, 클래스들은 여전히 서로 강하게 결합되어 있다.

이전 예제에서 클래스를 완전히 분리하기 위해 앞에서 언급한 의존성 주입 개념을 구현해 본다.

의존성 주입과 제어 역전의 원칙(IoC)은 종종 함께 다뤄진다.

제어 역전에 대한 한 가지 정의는 다른 사람이 의존체를 인스턴스화해 전달하게 하는 것이다.

이것을 바로 이번 예제에서 구현할 것이다.

모든 포유류가 날고 걷고 헤엄치는 것은 아니기 때문에 분리과정을 위해 포유류의 행위를 나타내는 인터페이스를 만든다.

```java
interface IWalkable{
  public void walk();
}
```

이 인터페이스의 유일한 메서드는 walk()이며, 구현부를 제공하기 위해 구상 클래스에 남겨진다.

```java
class Dog extends Mammal implements IWalkable{
  IWalkable walker;

  public void setWalker(IWalkable walker){
    this.walker = walker;
  }

  public void walk(){
    walker.walk();
  }
}
```

Dog 클래스는 Mammal 클래스를 확장하고 IWalkable 인터페이스를 구현한다.

또한 Dog 클래스는 의존성을 주입하는 메커니즘을 제공하는 참조 및 세터를 제공한다.

```java
IWalkable walker;

public void setWalker(IWalkable walker){
  this.walker = walker;
}
```

간단하게 말해서 이것이 의존성 주입이다.

Walkable 행위는 새 키워드를 사용해 Dog클래스 내에 작성되지 않는다.

매개변수 목록을 통해 Dog클래스에 주입된다.

```java
class Mammal{
  public void eat() { System.out.println("I am eating"); }
}

interface IWalkable{
  public void walk();
}

class Dog extends Mammal implements IWalkable{
  IWalkable walker;

  public void setWalker(IWalkable walker){
    this.walker = walker;
  }

  public void walk(){
    walker.walk();
  }

  public class TestMammal{
    public static void main(String[] args){
      Walkable walker - new Walkable();
      Dog fido = new Dog();
      fido.setWalker(walker);
      fido.eat();
      fido.walk();
    }
  }
}
```

이 예제에서는 세터를 사용해 의존성을 주입하지만 이 방법이 유일하지는 않다.

*생성자를 통해서 주입하는 방법*

### 11.2. 결론

의존성 주입은 구현한 클래스의 구성을 클래스 의존체들의 구성으로부터 분리한다.  

이는 매번 자신만의 것을 직접 제작하는 대신에 상품 진열대에서 무언가를 구입해오는 일과 같다.

이게 상속과 합성에 대한 토론의 핵심이다.

단순히 토론이라는 점에 유의해야 한다.(정답x)  

스스로 상속과 합성에 대한 문제를 생각하고 설계에 반영해야 한다.
